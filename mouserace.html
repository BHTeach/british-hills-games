<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Classroom Maze</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* iOS Safari Specific Tweaks */
        body {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
            background-color: #000;
        }
        
        .maze-grid {
            display: grid;
            gap: 2px;
            background-color: #000;
            border: 4px solid #1e293b; /* slate-800 */
        }
        
        .cell {
            position: relative;
            background-color: #e2e8f0; /* slate-200 (Path) */
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .wall {
            background-color: #0f172a; /* slate-900 (Wall) */
        }
        
        .start {
            background-color: #60a5fa; /* blue-400 */
        }
        
        .end {
            background-color: #4ade80; /* green-400 */
        }
        
        /* Smooth transition for movement */
        .character {
            transition: all 0.3s ease-in-out;
        }

        /* Safe area for iPhone/iPad notch/home bar */
        .safe-padding {
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
    </style>
</head>
<body class="h-[100dvh] w-screen overflow-hidden text-white">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Game Constants ---
        const GRID_SIZE = 7;
        
        // 0: Empty, 1: Wall, 2: Start, 3: End
        const LEVEL_1 = [
            [1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 1, 0, 3, 1],
            [1, 1, 0, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1],
        ];

        // Directions: 0: Up, 1: Right, 2: Down, 3: Left
        const DIRECTIONS = [
            { dx: 0, dy: -1, label: 'North' },
            { dx: 1, dy: 0, label: 'East' },
            { dx: 0, dy: 1, label: 'South' },
            { dx: -1, dy: 0, label: 'West' },
        ];

        // --- Audio Helpers ---
        const audioCtxRef = { current: null };

        const initAudio = () => {
            if (!audioCtxRef.current) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtxRef.current = new AudioContext();
            }
            if (audioCtxRef.current.state === 'suspended') {
                audioCtxRef.current.resume();
            }
        };

        const playTone = (freq, type, duration) => {
            if (!audioCtxRef.current) return;
            const osc = audioCtxRef.current.createOscillator();
            const gain = audioCtxRef.current.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtxRef.current.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtxRef.current.destination);
            osc.start();
            osc.stop(audioCtxRef.current.currentTime + duration);
        };

        const playMoveSound = () => playTone(300, 'sine', 0.1);
        const playBumpSound = () => playTone(150, 'sawtooth', 0.2);
        const playWinSound = () => {
            playTone(400, 'sine', 0.1);
            setTimeout(() => playTone(600, 'sine', 0.1), 100);
            setTimeout(() => playTone(800, 'sine', 0.2), 200);
        };
        const playListenSound = () => playTone(800, 'sine', 0.05);

        // --- Main Component ---
        function App() {
            // Game State
            const [gameState, setGameState] = useState('START'); // START, PLAYING, WON
            const [player, setPlayer] = useState({ x: 1, y: 1, dir: 1 }); // Start at 1,1 facing Right
            const [grid, setGrid] = useState(LEVEL_1);
            
            // Speech State
            const [isListening, setIsListening] = useState(false);
            const [transcript, setTranscript] = useState("");
            const [errorMsg, setErrorMsg] = useState("");

            // Refs for State
            const recognitionRef = useRef(null);
            const playerRef = useRef(player);
            const gridRef = useRef(grid);
            const gameStateRef = useRef(gameState);
            const shouldListenRef = useRef(false);

            // Keep refs synced
            useEffect(() => { playerRef.current = player; }, [player]);
            useEffect(() => { gridRef.current = grid; }, [grid]);
            useEffect(() => { gameStateRef.current = gameState; }, [gameState]);

            // --- Game Logic ---
            const resetGame = () => {
                setPlayer({ x: 1, y: 1, dir: 1 }); 
                setGameState('PLAYING');
                setTranscript("Ready!");
                initAudio();
            };

            const isValidMove = (x, y) => {
                if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;
                return gridRef.current[y][x] !== 1; // 1 is Wall
            };

            const checkWin = (x, y) => {
                if (gridRef.current[y][x] === 3) { // 3 is End
                    setGameState('WON');
                    playWinSound();
                    if ('speechSynthesis' in window) {
                         const utterance = new SpeechSynthesisUtterance("You won!");
                         window.speechSynthesis.speak(utterance);
                    }
                }
            };

            const processCommandRef = useRef();
            processCommandRef.current = (text) => {
                if (gameStateRef.current !== 'PLAYING') return;

                const p = playerRef.current;
                let newX = p.x;
                let newY = p.y;
                let newDir = p.dir;
                let commandFound = false;
                let action = "";

                // Strict Matching
                const cleanText = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").trim().toLowerCase();

                if (cleanText === "go forward") {
                    newX += DIRECTIONS[p.dir].dx;
                    newY += DIRECTIONS[p.dir].dy;
                    action = "Forward";
                    commandFound = true;
                } else if (cleanText === "go back") {
                    newX -= DIRECTIONS[p.dir].dx;
                    newY -= DIRECTIONS[p.dir].dy;
                    action = "Back";
                    commandFound = true;
                } else if (cleanText === "turn left") {
                    newDir = (p.dir - 1 + 4) % 4;
                    action = "Turn Left";
                    commandFound = true;
                } else if (cleanText === "turn right") {
                    newDir = (p.dir + 1) % 4;
                    action = "Turn Right";
                    commandFound = true;
                }

                if (commandFound) {
                    setTranscript(`Cmd: ${action}`);
                    if (action.includes("Turn")) {
                        setPlayer({ ...p, dir: newDir });
                        playMoveSound();
                    } else {
                        if (isValidMove(newX, newY)) {
                            setPlayer({ ...p, x: newX, y: newY });
                            playMoveSound();
                            checkWin(newX, newY);
                        } else {
                            playBumpSound();
                            setTranscript("Bonk! Wall.");
                        }
                    }
                } else {
                     // Debug: show rejected words (helpful for teacher)
                    const display = cleanText.length > 20 ? cleanText.substring(0, 20) + "..." : cleanText;
                    setTranscript(`Ignored: "${display}"`);
                }
            };

            // --- Speech Initialization ---
            useEffect(() => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (SpeechRecognition) {
                    const recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = false;
                    recognition.lang = 'en-US';

                    recognition.onstart = () => {
                        setIsListening(true);
                        setTranscript("Listening...");
                        setErrorMsg("");
                    };

                    recognition.onend = () => {
                        setIsListening(false);
                        if (shouldListenRef.current && gameStateRef.current === 'PLAYING') {
                            try { recognition.start(); } catch (e) { console.log("Restart failed", e); }
                        }
                    };

                    recognition.onerror = (event) => {
                        if (event.error === 'not-allowed') {
                            setErrorMsg("Microphone access denied.");
                            shouldListenRef.current = false;
                            setIsListening(false);
                        }
                    };

                    recognition.onresult = (event) => {
                        const latestResult = event.results[event.results.length - 1];
                        if (latestResult.isFinal) {
                            processCommandRef.current(latestResult[0].transcript);
                        }
                    };
                    recognitionRef.current = recognition;
                } else {
                    setErrorMsg("Browser not supported.");
                }

                return () => {
                    shouldListenRef.current = false;
                    if (recognitionRef.current) recognitionRef.current.abort();
                };
            }, []);

            // --- Manual Controls ---
            const toggleListen = () => {
                if (!recognitionRef.current) return;
                initAudio();
                
                if (isListening) {
                    shouldListenRef.current = false;
                    recognitionRef.current.stop();
                } else {
                    shouldListenRef.current = true;
                    playListenSound();
                    try { recognitionRef.current.start(); } catch (e) {}
                }
            };

            // --- Icons ---
            const getMouseRotation = () => player.dir * 90;
            const MouseIcon = () => (
                <svg width="70%" height="70%" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ transform: `rotate(${getMouseRotation()}deg)`, transition: 'transform 0.3s' }}>
                    <path d="M12 2L19 22L12 18L5 22L12 2Z" fill="#ef4444" /> {/* Red Mouse for Visibility */}
                </svg>
            );
            const CheeseIcon = () => (
                 <svg width="70%" height="70%" viewBox="0 0 24 24" fill="none" stroke="#16a34a" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 2C8 2 4 6 4 10V18C4 20 6 22 10 22H14C18 22 20 20 20 18V10C20 6 16 2 12 2Z" />
                    <circle cx="10" cy="10" r="2" fill="#16a34a"/>
                    <circle cx="14" cy="14" r="2" fill="#16a34a"/>
                </svg>
            );

            return (
                <div className="safe-padding flex flex-col md:flex-row h-full w-full items-center justify-center p-4 gap-6 bg-black">
                    
                    {/* LEFT SIDE: MAZE */}
                    <div className="flex-1 h-full max-h-[90vh] aspect-square flex items-center justify-center relative">
                        
                        {/* Overlays */}
                        {gameState === 'START' && (
                            <div className="absolute inset-0 z-20 bg-black/80 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm border border-slate-700">
                                <h2 className="text-white text-4xl font-bold mb-6">Classroom Maze</h2>
                                <button onClick={resetGame} className="px-10 py-5 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold text-2xl shadow-lg">
                                    Load Level 1
                                </button>
                            </div>
                        )}

                        {gameState === 'WON' && (
                            <div className="absolute inset-0 z-20 bg-green-900/90 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm border border-green-500">
                                <h2 className="text-white text-5xl font-bold mb-6">Great Job! ðŸŽ‰</h2>
                                <button onClick={resetGame} className="px-10 py-5 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold text-2xl shadow-lg">
                                    Play Again
                                </button>
                            </div>
                        )}

                        <div 
                            className="maze-grid rounded-lg overflow-hidden shadow-2xl w-full h-full"
                            style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)` }}
                        >
                            {grid.map((row, y) => (
                                row.map((cell, x) => (
                                    <div key={`${x}-${y}`} className={`cell ${cell === 1 ? 'wall' : cell === 2 ? 'start' : cell === 3 ? 'end' : ''}`}>
                                        {player.x === x && player.y === y && (
                                            <div className="absolute inset-0 flex items-center justify-center z-10 text-red-600">
                                                <MouseIcon />
                                            </div>
                                        )}
                                        {cell === 3 && (
                                            <div className="absolute inset-0 flex items-center justify-center opacity-70">
                                                <CheeseIcon />
                                            </div>
                                        )}
                                    </div>
                                ))
                            ))}
                        </div>
                    </div>

                    {/* RIGHT SIDE: CONTROLS */}
                    <div className="w-full md:w-1/3 flex flex-col gap-6 justify-center">
                        
                        {/* Status Box */}
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl text-center">
                            <h2 className="text-slate-400 text-sm uppercase tracking-wider mb-2">Command Heard</h2>
                            <div className="text-2xl font-mono font-bold text-yellow-400 min-h-[40px]">
                                {transcript || "..."}
                            </div>
                        </div>
                        
                        {/* Big Start/Stop Button */}
                        <button 
                            className={`w-full py-8 rounded-2xl font-bold text-3xl shadow-lg transition-all border-4 ${
                                isListening 
                                    ? 'bg-red-600 border-red-800 text-white animate-pulse' 
                                    : 'bg-green-600 border-green-800 text-white hover:bg-green-500'
                            }`}
                            onMouseDown={toggleListen}
                            onTouchStart={toggleListen}
                            disabled={gameState === 'WON'}
                        >
                            {isListening ? "STOP LISTENING" : "START GAME"}
                        </button>
                        
                        {/* Cheat Sheet */}
                        <div className="bg-slate-900 border border-slate-700 p-4 rounded-xl">
                            <h3 className="text-slate-500 text-xs uppercase mb-2">Valid Commands</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm text-slate-300 font-mono">
                                <div className="bg-slate-800 p-2 rounded">Go forward</div>
                                <div className="bg-slate-800 p-2 rounded">Go back</div>
                                <div className="bg-slate-800 p-2 rounded">Turn left</div>
                                <div className="bg-slate-800 p-2 rounded">Turn right</div>
                            </div>
                        </div>

                        <p className="text-center text-slate-500 text-xs">
                            {errorMsg || "Tap START GAME to enable microphone"}
                        </p>
                    </div>

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
