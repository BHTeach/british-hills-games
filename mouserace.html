<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Classroom Maze</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* iOS Safari Specific Tweaks */
        body {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }
        .maze-grid {
            display: grid;
            gap: 2px;
            background-color: #333;
            border: 4px solid #333;
        }
        .cell {
            position: relative;
            background-color: #e5e7eb; /* gray-200 */
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .wall {
            background-color: #1f2937; /* gray-800 */
        }
        .start {
            background-color: #bfdbfe; /* blue-200 */
        }
        .end {
            background-color: #bbf7d0; /* green-200 */
        }
        
        /* Smooth transition for movement */
        .character {
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-slate-100 h-screen w-screen overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Game Constants ---
        const GRID_SIZE = 7;
        
        // 0: Empty, 1: Wall, 2: Start, 3: End
        const LEVEL_1 = [
            [1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 1, 0, 3, 1],
            [1, 1, 0, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1],
        ];

        // Directions: 0: Up, 1: Right, 2: Down, 3: Left
        const DIRECTIONS = [
            { dx: 0, dy: -1, label: 'North' },
            { dx: 1, dy: 0, label: 'East' },
            { dx: 0, dy: 1, label: 'South' },
            { dx: -1, dy: 0, label: 'West' },
        ];

        // --- Audio Helpers ---
        const audioCtxRef = { current: null };

        const initAudio = () => {
            if (!audioCtxRef.current) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtxRef.current = new AudioContext();
            }
            if (audioCtxRef.current.state === 'suspended') {
                audioCtxRef.current.resume();
            }
        };

        const playTone = (freq, type, duration) => {
            if (!audioCtxRef.current) return;
            const osc = audioCtxRef.current.createOscillator();
            const gain = audioCtxRef.current.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtxRef.current.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtxRef.current.destination);
            osc.start();
            osc.stop(audioCtxRef.current.currentTime + duration);
        };

        const playMoveSound = () => playTone(300, 'sine', 0.1);
        const playBumpSound = () => playTone(150, 'sawtooth', 0.2);
        const playWinSound = () => {
            playTone(400, 'sine', 0.1);
            setTimeout(() => playTone(600, 'sine', 0.1), 100);
            setTimeout(() => playTone(800, 'sine', 0.2), 200);
        };
        const playListenSound = () => playTone(800, 'sine', 0.05);

        // --- Main Component ---
        function App() {
            // Game State
            const [gameState, setGameState] = useState('START'); // START, PLAYING, WON
            const [player, setPlayer] = useState({ x: 1, y: 1, dir: 1 }); // Start at 1,1 facing Right
            const [grid, setGrid] = useState(LEVEL_1);
            
            // Speech State
            const [isListening, setIsListening] = useState(false);
            const [transcript, setTranscript] = useState("");
            const [errorMsg, setErrorMsg] = useState("");

            // Refs for State (needed for Event Listeners)
            const recognitionRef = useRef(null);
            const playerRef = useRef(player);
            const gridRef = useRef(grid);
            const gameStateRef = useRef(gameState);
            
            // Should Listen Ref to handle auto-restarts if desired
            const shouldListenRef = useRef(false);

            // Keep refs synced with state
            useEffect(() => { playerRef.current = player; }, [player]);
            useEffect(() => { gridRef.current = grid; }, [grid]);
            useEffect(() => { gameStateRef.current = gameState; }, [gameState]);

            // --- Game Logic ---
            const resetGame = () => {
                setPlayer({ x: 1, y: 1, dir: 1 }); // Reset to start
                setGameState('PLAYING');
                setTranscript("Ready!");
                initAudio();
            };

            const isValidMove = (x, y) => {
                if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;
                return gridRef.current[y][x] !== 1; // 1 is Wall
            };

            const checkWin = (x, y) => {
                if (gridRef.current[y][x] === 3) { // 3 is End
                    setGameState('WON');
                    playWinSound();
                    if ('speechSynthesis' in window) {
                         const utterance = new SpeechSynthesisUtterance("You won!");
                         window.speechSynthesis.speak(utterance);
                    }
                }
            };

            // Use a ref for processCommand so the useEffect closure is stable,
            // but the logic inside always uses fresh data/refs.
            const processCommandRef = useRef();

            processCommandRef.current = (text) => {
                if (gameStateRef.current !== 'PLAYING') return;

                const p = playerRef.current;
                let newX = p.x;
                let newY = p.y;
                let newDir = p.dir;
                let commandFound = false;
                let action = "";

                // Strict Matching Logic
                // clean text: remove punctuation, lowercase, trim
                const cleanText = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").trim().toLowerCase();

                if (cleanText === "go forward") {
                    newX += DIRECTIONS[p.dir].dx;
                    newY += DIRECTIONS[p.dir].dy;
                    action = "Forward";
                    commandFound = true;
                } else if (cleanText === "go back") {
                    newX -= DIRECTIONS[p.dir].dx;
                    newY -= DIRECTIONS[p.dir].dy;
                    action = "Back";
                    commandFound = true;
                } else if (cleanText === "turn left") {
                    newDir = (p.dir - 1 + 4) % 4;
                    action = "Turn Left";
                    commandFound = true;
                } else if (cleanText === "turn right") {
                    newDir = (p.dir + 1) % 4;
                    action = "Turn Right";
                    commandFound = true;
                }

                if (commandFound) {
                    setTranscript(`Cmd: ${action}`);
                    
                    if (action.includes("Turn")) {
                        setPlayer({ ...p, dir: newDir });
                        playMoveSound();
                    } else {
                        if (isValidMove(newX, newY)) {
                            setPlayer({ ...p, x: newX, y: newY });
                            playMoveSound();
                            checkWin(newX, newY);
                        } else {
                            playBumpSound();
                            setTranscript("Bonk! Wall.");
                        }
                    }
                } else {
                    // Show what was heard if it wasn't a command, for debugging/teaching
                    // limit length to avoid UI overflow
                    const display = cleanText.length > 20 ? cleanText.substring(0, 20) + "..." : cleanText;
                    setTranscript(`Heard: "${display}"`);
                }
            };

            // --- Speech Initialization ---
            useEffect(() => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (SpeechRecognition) {
                    const recognition = new SpeechRecognition();
                    recognition.continuous = true; // CHANGED: Try continuous
                    recognition.interimResults = false;
                    recognition.lang = 'en-US';

                    recognition.onstart = () => {
                        setIsListening(true);
                        setTranscript("Listening...");
                        setErrorMsg("");
                    };

                    recognition.onend = () => {
                        setIsListening(false);
                        // If we intend to keep listening but it stopped (iOS timeout), restart it
                        if (shouldListenRef.current && gameStateRef.current === 'PLAYING') {
                            console.log("Auto-restarting speech recognition...");
                            try {
                                recognition.start();
                            } catch (e) {
                                console.log("Restart failed", e);
                            }
                        }
                    };

                    recognition.onerror = (event) => {
                        console.error("Speech Error", event.error);
                        if (event.error === 'not-allowed') {
                            setErrorMsg("Microphone access denied.");
                            shouldListenRef.current = false;
                            setIsListening(false);
                        }
                    };

                    recognition.onresult = (event) => {
                        // In continuous mode, we look at the latest result
                        const latestResult = event.results[event.results.length - 1];
                        if (latestResult.isFinal) {
                            const text = latestResult[0].transcript;
                            processCommandRef.current(text);
                        }
                    };

                    recognitionRef.current = recognition;
                } else {
                    setErrorMsg("Browser not supported. Use Safari/Chrome.");
                }

                return () => {
                    shouldListenRef.current = false;
                    if (recognitionRef.current) recognitionRef.current.abort();
                };
            }, []); // Empty dependency array ensures we don't restart mic on every render

            // --- Manual Controls ---
            const toggleListen = () => {
                if (!recognitionRef.current) return;
                initAudio();
                
                if (isListening) {
                    shouldListenRef.current = false;
                    recognitionRef.current.stop();
                } else {
                    shouldListenRef.current = true;
                    playListenSound();
                    try {
                        recognitionRef.current.start();
                    } catch (e) {
                        console.log("Mic start error", e);
                    }
                }
            };

            // --- Icons ---
            const getMouseRotation = () => player.dir * 90;

            const MouseIcon = () => (
                <svg width="60%" height="60%" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ transform: `rotate(${getMouseRotation()}deg)`, transition: 'transform 0.3s' }}>
                    <path d="M12 2L19 22L12 18L5 22L12 2Z" fill="#3b82f6" />
                </svg>
            );

            const CheeseIcon = () => (
                 <svg width="60%" height="60%" viewBox="0 0 24 24" fill="none" stroke="#eab308" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 2C8 2 4 6 4 10V18C4 20 6 22 10 22H14C18 22 20 20 20 18V10C20 6 16 2 12 2Z" />
                    <circle cx="10" cy="10" r="2" fill="#eab308"/>
                    <circle cx="14" cy="14" r="2" fill="#eab308"/>
                </svg>
            );

            return (
                <div className="flex flex-col h-full items-center justify-center p-4 max-w-4xl mx-auto">
                    
                    {/* Header */}
                    <div className="w-full flex justify-between items-center mb-4 bg-white p-4 rounded-xl shadow-sm">
                        <div>
                            <h1 className="text-xl font-bold text-slate-800">EFL Maze</h1>
                            <p className="text-xs text-slate-500 hidden sm:block">"Go forward", "Go back", "Turn left", "Turn right"</p>
                        </div>
                        <div className={`px-4 py-2 rounded-lg font-bold ${isListening ? 'bg-red-100 text-red-600 animate-pulse' : 'bg-slate-100 text-slate-400'}`}>
                            {isListening ? "Listening..." : "Mic Off"}
                        </div>
                    </div>

                    {/* Game Area */}
                    <div className="relative mb-6">
                        {gameState === 'START' && (
                            <div className="absolute inset-0 z-20 bg-slate-900/80 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm">
                                <h2 className="text-white text-3xl font-bold mb-4">Classroom Maze</h2>
                                <button 
                                    onClick={resetGame}
                                    className="px-8 py-4 bg-blue-500 hover:bg-blue-600 text-white rounded-xl font-bold text-xl shadow-lg transform transition active:scale-95"
                                >
                                    Start Game
                                </button>
                                <p className="text-slate-300 mt-4 text-center max-w-xs text-sm">
                                    Teacher: Ensure volume is up.
                                </p>
                            </div>
                        )}

                        {gameState === 'WON' && (
                            <div className="absolute inset-0 z-20 bg-green-900/90 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm">
                                <h2 className="text-white text-4xl font-bold mb-4">Great Job! ðŸŽ‰</h2>
                                <button 
                                    onClick={resetGame}
                                    className="px-8 py-4 bg-green-500 hover:bg-green-600 text-white rounded-xl font-bold text-xl shadow-lg"
                                >
                                    Play Again
                                </button>
                            </div>
                        )}

                        {/* Maze Grid */}
                        <div 
                            className="maze-grid rounded-lg overflow-hidden shadow-2xl"
                            style={{ 
                                gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)`,
                                width: 'min(90vw, 500px)', 
                            }}
                        >
                            {grid.map((row, y) => (
                                row.map((cell, x) => (
                                    <div key={`${x}-${y}`} className={`cell ${cell === 1 ? 'wall' : cell === 2 ? 'start' : cell === 3 ? 'end' : ''}`}>
                                        {player.x === x && player.y === y && (
                                            <div className="absolute inset-0 flex items-center justify-center z-10">
                                                <MouseIcon />
                                            </div>
                                        )}
                                        {cell === 3 && (
                                            <div className="absolute inset-0 flex items-center justify-center opacity-50">
                                                <CheeseIcon />
                                            </div>
                                        )}
                                    </div>
                                ))
                            ))}
                        </div>
                    </div>

                    {/* Teacher Controls */}
                    <div className="w-full max-w-md flex flex-col gap-4">
                        
                        {/* Feedback Display */}
                        <div className="bg-white p-3 rounded-lg shadow text-center min-h-[60px] flex items-center justify-center">
                            <span className="text-lg font-medium text-slate-700">
                                {transcript || "Waiting for command..."}
                            </span>
                        </div>
                        
                        {/* Big Button */}
                        <button 
                            className={`w-full py-6 rounded-2xl font-bold text-2xl shadow-lg transition-all touch-manipulation ${
                                isListening 
                                    ? 'bg-red-500 text-white active:bg-red-600 shadow-red-200' 
                                    : 'bg-green-500 text-white active:bg-green-600 shadow-green-200'
                            }`}
                            onMouseDown={toggleListen}
                            onTouchStart={toggleListen}
                            disabled={gameState === 'WON'}
                        >
                            {isListening ? "STOP LISTENING" : "Start Game"}
                        </button>
                        
                        <p className="text-center text-slate-400 text-xs mt-2">
                            {errorMsg || "Teacher: Tap button to toggle voice recognition"}
                        </p>
                    </div>

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
