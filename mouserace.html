<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Mouse Maze 3 (Forest Edition)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Retro Font -->
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        /* iOS Safari Specific Tweaks */
        body {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
            background-color: #7dd3fc; /* Sky Blue */
            font-family: 'VT323', monospace;
            color: #451a03; /* Dark Brown Text */
        }
        
        /* Pixel Art Rendering */
        canvas, img, svg {
            image-rendering: pixelated;
            shape-rendering: crispEdges;
        }

        .maze-container {
            position: relative;
            background-color: #22c55e;
            border: 8px solid #713f12; /* Wood border */
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .maze-grid {
            display: grid;
            gap: 0px; 
            width: 100%;
            height: 100%;
        }
        
        .cell {
            position: relative;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- FOREST TEXTURES --- */
        
        /* Grass Floor */
        .floor {
            background-color: #86efac; /* Light Green */
            /* Random grass tufts pattern using gradients */
            background-image: 
                radial-gradient(#4ade80 15%, transparent 16%),
                radial-gradient(#4ade80 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }
        
        /* Hedge/Tree Wall */
        .wall {
            background-color: #14532d; /* Dark Green */
            /* Leafy texture */
            background-image: 
                radial-gradient(circle at 50% 50%, #166534 40%, transparent 41%),
                radial-gradient(circle at 0% 0%, #166534 30%, transparent 31%),
                radial-gradient(circle at 100% 100%, #166534 30%, transparent 31%),
                radial-gradient(circle at 0% 100%, #166534 30%, transparent 31%),
                radial-gradient(circle at 100% 0%, #166534 30%, transparent 31%);
            background-size: 20px 20px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            border-radius: 4px; /* Slightly rounded for bushes */
        }
        
        /* Dirt Path (Start) */
        .start { 
            background-color: #d97706; /* Amber/Dirt */
            background-image: repeating-linear-gradient(45deg, #b45309 0, #b45309 2px, transparent 2px, transparent 8px);
            opacity: 0.9;
        }
        
        /* Cheese Zone (End) */
        .end { 
            background-color: #fef9c3; /* Light Yellow */
            opacity: 0.5;
        }

        /* --- JUICE ANIMATIONS --- */
        
        @keyframes idle-bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes hop {
            0% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.2) translateY(-10%); }
            100% { transform: scale(1) translateY(0); }
        }

        @keyframes bonk {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-5deg); }
            75% { transform: translateX(5px) rotate(5deg); }
            100% { transform: translateX(0); }
        }

        .animate-idle {
            animation: idle-bounce 2s infinite ease-in-out;
        }

        .animate-hop {
            animation: hop 0.3s ease-out;
        }

        .animate-bonk {
            animation: bonk 0.2s ease-in-out;
        }

        .safe-padding {
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Wood UI Panel */
        .ui-panel {
            background-color: #fef3c7; /* Parchment */
            border: 4px solid #78350f; /* Wood */
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            border-radius: 8px;
        }
    </style>
</head>
<body class="h-[100dvh] w-screen overflow-hidden">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Game Constants ---
        const GRID_SIZE = 11;
        
        const LEVEL_1 = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 1, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        const INITIAL_PLAYER = { x: 1, y: 1, dir: 1 };
        const INITIAL_CAT = { x: 9, y: 1 };

        const DIRECTIONS = [
            { dx: 0, dy: -1, label: 'North' },
            { dx: 1, dy: 0, label: 'East' },
            { dx: 0, dy: 1, label: 'South' },
            { dx: -1, dy: 0, label: 'West' },
        ];

        // --- Audio Helpers ---
        const audioCtxRef = { current: null };

        const initAudio = () => {
            if (!audioCtxRef.current) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtxRef.current = new AudioContext();
            }
            if (audioCtxRef.current.state === 'suspended') {
                audioCtxRef.current.resume();
            }
        };

        const playTone = (freq, type, duration) => {
            if (!audioCtxRef.current) return;
            const osc = audioCtxRef.current.createOscillator();
            const gain = audioCtxRef.current.createGain();
            osc.type = type; 
            osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
            gain.gain.setValueAtTime(0.05, audioCtxRef.current.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtxRef.current.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtxRef.current.destination);
            osc.start();
            osc.stop(audioCtxRef.current.currentTime + duration);
        };

        const playMoveSound = () => playTone(400, 'sine', 0.1); 
        const playBumpSound = () => playTone(150, 'sawtooth', 0.2);
        const playWinSound = () => {
            playTone(523.25, 'sine', 0.1); 
            setTimeout(() => playTone(659.25, 'sine', 0.1), 100); 
            setTimeout(() => playTone(783.99, 'sine', 0.2), 200); 
        };
        const playLoseSound = () => {
            playTone(300, 'sawtooth', 0.2);
            setTimeout(() => playTone(200, 'sawtooth', 0.4), 200);
        };
        const playListenSound = () => playTone(880, 'sine', 0.1);

        // --- Cat Logic (BFS) ---
        const getNextCatMove = (catPos, playerPos, grid) => {
            const queue = [{ x: catPos.x, y: catPos.y, path: [] }];
            const visited = new Set();
            visited.add(`${catPos.x},${catPos.y}`);
            let iterations = 0;

            while (queue.length > 0 && iterations < 500) {
                iterations++;
                const current = queue.shift();
                const { x, y, path } = current;

                if (x === playerPos.x && y === playerPos.y) return path.length > 0 ? path[0] : catPos;

                const moves = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

                for (const move of moves) {
                    const nx = x + move.dx;
                    const ny = y + move.dy;
                    if (nx >= 0 && ny >= 0 && nx < GRID_SIZE && ny < GRID_SIZE) {
                        const cell = grid[ny][nx];
                        const posKey = `${nx},${ny}`;
                        if (cell !== 1 && !visited.has(posKey)) {
                            visited.add(posKey);
                            queue.push({ x: nx, y: ny, path: [...path, {x: nx, y: ny}] });
                        }
                    }
                }
            }
            return catPos;
        };

        // --- Main Component ---
        function App() {
            const [gameState, setGameState] = useState('START');
            const [player, setPlayer] = useState(INITIAL_PLAYER);
            const [cat, setCat] = useState(INITIAL_CAT);
            const [isListening, setIsListening] = useState(false);
            const [transcript, setTranscript] = useState("");
            
            // Animation States
            const [playerAnim, setPlayerAnim] = useState(""); 
            
            const recognitionRef = useRef(null);
            const playerRef = useRef(player);
            const catRef = useRef(cat);
            const gameStateRef = useRef(gameState);
            const shouldListenRef = useRef(false);

            useEffect(() => { playerRef.current = player; }, [player]);
            useEffect(() => { catRef.current = cat; }, [cat]);
            useEffect(() => { gameStateRef.current = gameState; }, [gameState]);

            const triggerAnim = (type) => {
                setPlayerAnim(""); 
                setTimeout(() => setPlayerAnim(type), 10);
            };

            const resetGame = () => {
                setPlayer(INITIAL_PLAYER);
                setCat(INITIAL_CAT);
                setGameState('PLAYING');
                setTranscript("Ready!");
                setPlayerAnim("");
                initAudio();
            };

            const checkGameStatus = (pPos, cPos) => {
                if (LEVEL_1[pPos.y][pPos.x] === 3) {
                    setGameState('WON');
                    playWinSound();
                    speak("Yummy! You found the cheese!");
                    return true;
                }
                if (pPos.x === cPos.x && pPos.y === cPos.y) {
                    setGameState('LOST');
                    playLoseSound();
                    speak("Oh no! The cat caught you!");
                    return true;
                }
                return false;
            };

            const speak = (text) => {
                if ('speechSynthesis' in window) {
                     const utterance = new SpeechSynthesisUtterance(text);
                     window.speechSynthesis.speak(utterance);
                }
            };

            // Recursive function to execute list of commands
            const executeCommandSequence = (sequence, currentP, currentC) => {
                 if (sequence.length === 0 || gameStateRef.current !== 'PLAYING') return;

                 const cmd = sequence[0];
                 const remaining = sequence.slice(1);
                 
                 let nextP = { ...currentP };
                 let nextC = { ...currentC };

                 // 1. EXECUTE PLAYER ACTION
                 if (cmd.type === "turn") {
                     const newDir = (currentP.dir + cmd.change + 4) % 4;
                     nextP = { ...currentP, dir: newDir };
                     setPlayer(nextP);
                     playMoveSound();
                     triggerAnim("animate-hop");
                 } else if (cmd.type === "move") {
                     // Determine vector based on CURRENT direction
                     const moveDir = DIRECTIONS[currentP.dir];
                     const mult = cmd.action === "Forward" ? 1 : -1;
                     const targetX = currentP.x + (moveDir.dx * mult);
                     const targetY = currentP.y + (moveDir.dy * mult);

                     if (targetX >= 0 && targetY >= 0 && targetX < GRID_SIZE && targetY < GRID_SIZE && LEVEL_1[targetY][targetX] !== 1) {
                         nextP = { ...currentP, x: targetX, y: targetY };
                         setPlayer(nextP);
                         playMoveSound();
                         triggerAnim("animate-hop");
                     } else {
                         playBumpSound();
                         triggerAnim("animate-bonk");
                         setTranscript("BONK!");
                         // Player blocked
                     }
                 }

                 // Check Win
                 if (checkGameStatus(nextP, currentC)) return;

                 // 2. CAT MOVES (Only if player command was a MOVE, not a turn)
                 if (cmd.type === 'move') {
                     nextC = getNextCatMove(currentC, nextP, LEVEL_1);
                     setCat(nextC);
                 }
                 
                 // Check Loss
                 if (checkGameStatus(nextP, nextC)) return;

                 // 3. SCHEDULE NEXT MOVE
                 if (remaining.length > 0) {
                     setTimeout(() => {
                         executeCommandSequence(remaining, nextP, nextC);
                     }, 100); // Reduced to 100ms for "Immediate" feel
                 }
            };

            const processCommand = (text) => {
                if (gameStateRef.current !== 'PLAYING') return;

                const cleanText = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").toLowerCase();
                
                // Regex to find ALL valid commands in the string
                const regex = /(go forward|go back|turn left|turn right)/g;
                const matches = cleanText.match(regex);

                if (!matches || matches.length === 0) {
                     const display = cleanText.length > 20 ? cleanText.substring(0, 20) + "..." : cleanText;
                    setTranscript(`? "${display}"`);
                    return;
                }

                // Map matches to command objects
                const commandSequence = matches.map(match => {
                    if (match === 'go forward') return { action: "Forward", type: "move" };
                    if (match === 'go back') return { action: "Back", type: "move" };
                    if (match === 'turn left') return { action: "Turn Left", type: "turn", change: -1 };
                    if (match === 'turn right') return { action: "Turn Right", type: "turn", change: 1 };
                    return null;
                }).filter(Boolean);

                setTranscript(`Running ${commandSequence.length} moves...`);

                // Start sequence with current state
                executeCommandSequence(commandSequence, playerRef.current, catRef.current);
            };

            // Speech Setup
            useEffect(() => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (SpeechRecognition) {
                    const recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = false;
                    recognition.lang = 'en-US';

                    recognition.onstart = () => { setIsListening(true); setTranscript("Listening..."); };
                    recognition.onend = () => {
                        setIsListening(false);
                        if (shouldListenRef.current && gameStateRef.current === 'PLAYING') {
                            try { recognition.start(); } catch (e) {}
                        }
                    };
                    recognition.onresult = (event) => {
                        const latestResult = event.results[event.results.length - 1];
                        if (latestResult.isFinal) processCommand(latestResult[0].transcript);
                    };
                    recognitionRef.current = recognition;
                }
                return () => { shouldListenRef.current = false; if (recognitionRef.current) recognitionRef.current.abort(); };
            }, []);

            const toggleListen = () => {
                if (!recognitionRef.current) return;
                initAudio();
                if (isListening) {
                    shouldListenRef.current = false;
                    recognitionRef.current.stop();
                } else {
                    shouldListenRef.current = true;
                    playListenSound();
                    try { recognitionRef.current.start(); } catch (e) {}
                }
            };

            // --- Pixel Art SVGs ---
            const PixelMouse = () => (
                <svg viewBox="0 0 16 16" width="80%" height="80%" style={{ transform: `rotate(${player.dir * 90}deg)`, transition: 'transform 0.2s' }}>
                    <rect x="5" y="4" width="6" height="8" fill="#e2e8f0" /> {/* White/Grey Mouse */}
                    <rect x="4" y="2" width="3" height="3" fill="#94a3b8" />
                    <rect x="9" y="2" width="3" height="3" fill="#94a3b8" />
                    <rect x="7" y="12" width="2" height="3" fill="#f472b6" />
                    <rect x="6" y="5" width="1" height="1" fill="#000" />
                    <rect x="9" y="5" width="1" height="1" fill="#000" />
                </svg>
            );

            const PixelCat = () => (
                <svg viewBox="0 0 16 16" width="80%" height="80%">
                    <rect x="4" y="4" width="8" height="7" fill="#f97316" /> {/* Orange Tabby */}
                    <path d="M4 4 L4 1 L7 4 Z" fill="#c2410c" />
                    <path d="M12 4 L12 1 L9 4 Z" fill="#c2410c" />
                    <rect x="5" y="6" width="2" height="1" fill="#fff" />
                    <rect x="9" y="6" width="2" height="1" fill="#fff" />
                    <rect x="6" y="6" width="1" height="1" fill="#000" />
                    <rect x="9" y="6" width="1" height="1" fill="#000" />
                    <rect x="7" y="8" width="2" height="1" fill="#000" />
                </svg>
            );

            const PixelCheese = () => (
                <svg viewBox="0 0 16 16" width="80%" height="80%">
                    <rect x="4" y="6" width="8" height="6" fill="#facc15" />
                    <rect x="6" y="4" width="4" height="2" fill="#facc15" />
                    <rect x="5" y="7" width="1" height="1" fill="#ca8a04" />
                    <rect x="8" y="9" width="1" height="1" fill="#ca8a04" />
                    <rect x="10" y="7" width="1" height="1" fill="#ca8a04" />
                </svg>
            );

            return (
                <div className="safe-padding flex flex-col md:flex-row h-full w-full items-center justify-center p-4 gap-6">
                    
                    {/* Left: Maze */}
                    <div className="flex-1 h-full max-h-[95vh] aspect-square flex items-center justify-center relative">
                        
                        {/* Start Screen */}
                        {gameState === 'START' && (
                            <div className="absolute inset-0 z-20 bg-green-800/90 flex flex-col items-center justify-center rounded-lg border-4 border-amber-300 shadow-2xl">
                                <h1 className="text-6xl text-amber-300 mb-2 tracking-widest text-shadow">FOREST MAZE</h1>
                                <p className="text-xl text-green-100 mb-8 font-mono">PIXEL FOREST EDITION</p>
                                <button onClick={resetGame} className="px-8 py-4 bg-amber-500 hover:bg-amber-400 text-amber-900 text-2xl font-bold border-b-4 border-amber-800 active:border-b-0 active:translate-y-1 transition-all rounded">
                                    START ADVENTURE
                                </button>
                            </div>
                        )}

                        {/* End Screens */}
                        {gameState === 'WON' && (
                            <div className="absolute inset-0 z-20 bg-yellow-500/90 flex flex-col items-center justify-center rounded-lg border-4 border-white">
                                <h2 className="text-6xl text-white mb-4 animate-bounce">YUMMY!</h2>
                                <p className="text-xl text-yellow-100 mb-6">You found the cheese!</p>
                                <button onClick={resetGame} className="px-8 py-4 bg-white text-yellow-600 text-2xl font-bold border-b-4 border-yellow-200 active:border-b-0 active:translate-y-1 rounded">
                                    PLAY AGAIN
                                </button>
                            </div>
                        )}
                        {gameState === 'LOST' && (
                            <div className="absolute inset-0 z-20 bg-red-800/90 flex flex-col items-center justify-center rounded-lg border-4 border-red-400">
                                <h2 className="text-6xl text-red-200 mb-4">OH NO!</h2>
                                <button onClick={resetGame} className="px-8 py-4 bg-red-500 hover:bg-red-400 text-white text-2xl font-bold border-b-4 border-red-800 active:border-b-0 active:translate-y-1 rounded">
                                    TRY AGAIN
                                </button>
                            </div>
                        )}

                        <div className="maze-container w-full h-full">
                            <div className="maze-grid" style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)` }}>
                                {LEVEL_1.map((row, y) => (
                                    row.map((cell, x) => (
                                        <div key={`${x}-${y}`} className={`cell ${cell === 1 ? 'wall' : 'floor'} ${cell === 2 ? 'start' : cell === 3 ? 'end' : ''}`}>
                                            
                                            {/* Player */}
                                            {player.x === x && player.y === y && (
                                                <div className={`absolute inset-0 z-10 flex items-center justify-center ${playerAnim || 'animate-idle'}`}>
                                                    <PixelMouse />
                                                </div>
                                            )}
                                            
                                            {/* Cat */}
                                            {cat.x === x && cat.y === y && (
                                                <div className="absolute inset-0 z-10 flex items-center justify-center animate-idle">
                                                    <PixelCat />
                                                </div>
                                            )}

                                            {/* Goal */}
                                            {cell === 3 && (
                                                <div className="absolute inset-0 flex items-center justify-center animate-pulse">
                                                    <PixelCheese />
                                                </div>
                                            )}
                                        </div>
                                    ))
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Right: Controls */}
                    <div className="w-full md:w-1/3 flex flex-col gap-6 justify-center p-4">
                        
                        <div className="ui-panel p-6 relative">
                            <div className="absolute -top-3 left-4 bg-amber-100 px-2 text-amber-900 border border-amber-900 text-sm font-bold rounded">COMMAND LOG</div>
                            <div className="text-4xl text-green-700 text-center uppercase tracking-widest h-12 flex items-center justify-center">
                                {transcript || "READY"}
                            </div>
                        </div>
                        
                        <button 
                            className={`w-full py-6 text-3xl font-bold uppercase tracking-widest transition-all border-b-8 active:border-b-0 active:translate-y-2 rounded shadow-lg ${
                                isListening 
                                    ? 'bg-red-500 border-red-800 text-white animate-pulse' 
                                    : 'bg-green-500 border-green-800 text-white hover:bg-green-400'
                            }`}
                            onMouseDown={toggleListen}
                            onTouchStart={toggleListen}
                            disabled={gameState !== 'PLAYING'}
                        >
                            {isListening ? "STOP MIC" : "START MIC"}
                        </button>

                        <div className="grid grid-cols-2 gap-4 text-amber-900 font-bold text-sm">
                            <div className="bg-amber-100 p-2 text-center border-2 border-amber-900 rounded shadow-sm">GO FORWARD</div>
                            <div className="bg-amber-100 p-2 text-center border-2 border-amber-900 rounded shadow-sm">GO BACK</div>
                            <div className="bg-amber-100 p-2 text-center border-2 border-amber-900 rounded shadow-sm">TURN LEFT</div>
                            <div className="bg-amber-100 p-2 text-center border-2 border-amber-900 rounded shadow-sm">TURN RIGHT</div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
