<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Classroom Maze</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* iOS Safari Specific Tweaks */
        body {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }
        .maze-grid {
            display: grid;
            gap: 2px;
            background-color: #333;
            border: 4px solid #333;
        }
        .cell {
            position: relative;
            background-color: #e5e7eb; /* gray-200 */
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .wall {
            background-color: #1f2937; /* gray-800 */
        }
        .start {
            background-color: #bfdbfe; /* blue-200 */
        }
        .end {
            background-color: #bbf7d0; /* green-200 */
        }
        
        /* Smooth transition for movement */
        .character {
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-slate-100 h-screen w-screen overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Game Constants ---
        const GRID_SIZE = 7;
        
        // 0: Empty, 1: Wall, 2: Start, 3: End
        const LEVEL_1 = [
            [1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 1, 0, 3, 1],
            [1, 1, 0, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1],
        ];

        // Directions: 0: Up, 1: Right, 2: Down, 3: Left
        const DIRECTIONS = [
            { dx: 0, dy: -1, label: 'North' },
            { dx: 1, dy: 0, label: 'East' },
            { dx: 0, dy: 1, label: 'South' },
            { dx: -1, dy: 0, label: 'West' },
        ];

        // --- Audio Helpers (Synthesized to avoid external assets) ---
        const audioCtxRef = { current: null };

        const initAudio = () => {
            if (!audioCtxRef.current) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtxRef.current = new AudioContext();
            }
            if (audioCtxRef.current.state === 'suspended') {
                audioCtxRef.current.resume();
            }
        };

        const playTone = (freq, type, duration) => {
            if (!audioCtxRef.current) return;
            const osc = audioCtxRef.current.createOscillator();
            const gain = audioCtxRef.current.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtxRef.current.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtxRef.current.destination);
            osc.start();
            osc.stop(audioCtxRef.current.currentTime + duration);
        };

        const playMoveSound = () => playTone(300, 'sine', 0.1);
        const playBumpSound = () => playTone(150, 'sawtooth', 0.2);
        const playWinSound = () => {
            playTone(400, 'sine', 0.1);
            setTimeout(() => playTone(600, 'sine', 0.1), 100);
            setTimeout(() => playTone(800, 'sine', 0.2), 200);
        };
        const playListenSound = () => playTone(800, 'sine', 0.05);

        // --- Main Component ---
        function App() {
            // Game State
            const [gameState, setGameState] = useState('START'); // START, PLAYING, WON
            const [player, setPlayer] = useState({ x: 1, y: 1, dir: 1 }); // Start at 1,1 facing Right
            const [grid, setGrid] = useState(LEVEL_1);
            
            // Speech State
            const [isListening, setIsListening] = useState(false);
            const [transcript, setTranscript] = useState("");
            const [lastCommand, setLastCommand] = useState(null);
            const [errorMsg, setErrorMsg] = useState("");

            // Refs
            const recognitionRef = useRef(null);

            // --- Initialization ---
            useEffect(() => {
                // Initialize Speech Recognition
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (SpeechRecognition) {
                    const recognition = new SpeechRecognition();
                    recognition.continuous = false; // iOS requires this to be false for stability
                    recognition.interimResults = false; // We only want final results
                    recognition.lang = 'en-US';

                    recognition.onstart = () => {
                        setIsListening(true);
                        setTranscript("Listening...");
                        setErrorMsg("");
                    };

                    recognition.onend = () => {
                        setIsListening(false);
                        // Do not auto-restart on iOS - user must click again
                    };

                    recognition.onerror = (event) => {
                        console.error("Speech Error", event.error);
                        setIsListening(false);
                        if (event.error === 'not-allowed') {
                            setErrorMsg("Microphone access denied. Please check settings.");
                        } else {
                            setErrorMsg(`Error: ${event.error}`);
                        }
                    };

                    recognition.onresult = (event) => {
                        const text = event.results[0][0].transcript.toLowerCase();
                        setTranscript(`"${text}"`);
                        processCommand(text);
                    };

                    recognitionRef.current = recognition;
                } else {
                    setErrorMsg("Browser not supported. Please use Safari or Chrome.");
                }

                return () => {
                    if (recognitionRef.current) recognitionRef.current.abort();
                };
            }, [player, gameState]); // Re-bind if player state changes? No, processCommand needs latest state

            // --- Game Logic ---

            // We use a ref for player state inside the speech callback to avoid stale closures 
            // without complex dependency management, or we pass current state to command processor
            // Since onresult is a closure, let's use a Ref for current player state to be safe
            const playerRef = useRef(player);
            useEffect(() => { playerRef.current = player; }, [player]);
            
            const gameStateRef = useRef(gameState);
            useEffect(() => { gameStateRef.current = gameState; }, [gameState]);


            const resetGame = () => {
                setPlayer({ x: 1, y: 1, dir: 1 }); // Reset to start
                setGameState('PLAYING');
                setTranscript("Ready!");
                setLastCommand(null);
                initAudio();
            };

            const processCommand = (text) => {
                if (gameStateRef.current !== 'PLAYING') return;

                const p = playerRef.current;
                let newX = p.x;
                let newY = p.y;
                let newDir = p.dir;
                let commandFound = false;
                let action = "";

                // Fuzzy Matching Commands
                if (text.includes("forward") || text.includes("go") || text.includes("straight") || text.includes("move")) {
                    // Move Forward based on current direction
                    newX += DIRECTIONS[p.dir].dx;
                    newY += DIRECTIONS[p.dir].dy;
                    action = "Forward";
                    commandFound = true;
                } else if (text.includes("back")) {
                    // Move Backward based on current direction
                    newX -= DIRECTIONS[p.dir].dx;
                    newY -= DIRECTIONS[p.dir].dy;
                    action = "Back";
                    commandFound = true;
                } else if (text.includes("left")) {
                    // Turn Left
                    newDir = (p.dir - 1 + 4) % 4;
                    action = "Turn Left";
                    commandFound = true;
                } else if (text.includes("right")) {
                    // Turn Right
                    newDir = (p.dir + 1) % 4;
                    action = "Turn Right";
                    commandFound = true;
                }

                if (commandFound) {
                    setLastCommand(action);
                    speak(action); // TTS Feedback
                    
                    if (action.includes("Turn")) {
                        // Just rotation
                        setPlayer({ ...p, dir: newDir });
                        playMoveSound();
                    } else {
                        // Movement
                        if (isValidMove(newX, newY)) {
                            setPlayer({ ...p, x: newX, y: newY });
                            playMoveSound();
                            checkWin(newX, newY);
                        } else {
                            playBumpSound();
                            setTranscript("Bonk! Wall.");
                            speak("Wall");
                        }
                    }
                } else {
                    setTranscript(`Unknown: "${text}"`);
                }
            };

            const isValidMove = (x, y) => {
                if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;
                return grid[y][x] !== 1; // 1 is Wall
            };

            const checkWin = (x, y) => {
                if (grid[y][x] === 3) { // 3 is End
                    setGameState('WON');
                    playWinSound();
                    speak("You won!");
                }
            };

            const speak = (text) => {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.2;
                    window.speechSynthesis.speak(utterance);
                }
            };

            // --- Manual Controls (for Voice Fallback) ---
            const toggleListen = () => {
                if (!recognitionRef.current) return;
                initAudio(); // Ensure audio context is ready on click
                
                if (isListening) {
                    recognitionRef.current.stop();
                } else {
                    playListenSound();
                    try {
                        recognitionRef.current.start();
                    } catch (e) {
                        // Sometimes fails if already started, just ignore
                        console.log("Mic start error", e);
                    }
                }
            };

            // --- Render Helpers ---
            const getMouseRotation = () => {
                // 0: Up (0deg), 1: Right (90deg), 2: Down (180deg), 3: Left (270deg)
                // Default icon points Up? No, icons usually upright.
                // Let's assume we use an Arrow or Mouse icon that points UP by default.
                // Rotation: 0->0, 1->90, 2->180, 3->270
                return player.dir * 90;
            };

            // --- Icons ---
            const MouseIcon = () => (
                <svg width="60%" height="60%" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ transform: `rotate(${getMouseRotation()}deg)`, transition: 'transform 0.3s' }}>
                    <path d="M12 2L19 22L12 18L5 22L12 2Z" fill="#3b82f6" /> {/* Arrow style mouse */}
                </svg>
            );

            const CheeseIcon = () => (
                 <svg width="60%" height="60%" viewBox="0 0 24 24" fill="none" stroke="#eab308" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 2C8 2 4 6 4 10V18C4 20 6 22 10 22H14C18 22 20 20 20 18V10C20 6 16 2 12 2Z" />
                    <circle cx="10" cy="10" r="2" fill="#eab308"/>
                    <circle cx="14" cy="14" r="2" fill="#eab308"/>
                </svg>
            );

            return (
                <div className="flex flex-col h-full items-center justify-center p-4 max-w-4xl mx-auto">
                    
                    {/* Header / Scoreboard */}
                    <div className="w-full flex justify-between items-center mb-4 bg-white p-4 rounded-xl shadow-sm">
                        <div>
                            <h1 className="text-xl font-bold text-slate-800">EFL Maze</h1>
                            <p className="text-sm text-slate-500">Commands: Forward, Back, Left, Right</p>
                        </div>
                        <div className={`px-4 py-2 rounded-lg font-bold ${isListening ? 'bg-red-100 text-red-600 animate-pulse' : 'bg-slate-100 text-slate-400'}`}>
                            {isListening ? "Listening..." : "Mic Off"}
                        </div>
                    </div>

                    {/* Game Area */}
                    <div className="relative mb-6">
                        {gameState === 'START' && (
                            <div className="absolute inset-0 z-20 bg-slate-900/80 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm">
                                <h2 className="text-white text-3xl font-bold mb-4">Classroom Maze</h2>
                                <button 
                                    onClick={resetGame}
                                    className="px-8 py-4 bg-blue-500 hover:bg-blue-600 text-white rounded-xl font-bold text-xl shadow-lg transform transition active:scale-95"
                                >
                                    Start Game
                                </button>
                                <p className="text-slate-300 mt-4 text-center max-w-xs">
                                    Teacher: Tap to start. Ensure volume is up.
                                </p>
                            </div>
                        )}

                        {gameState === 'WON' && (
                            <div className="absolute inset-0 z-20 bg-green-900/90 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm">
                                <h2 className="text-white text-4xl font-bold mb-4">Great Job! ðŸŽ‰</h2>
                                <button 
                                    onClick={resetGame}
                                    className="px-8 py-4 bg-green-500 hover:bg-green-600 text-white rounded-xl font-bold text-xl shadow-lg"
                                >
                                    Play Again
                                </button>
                            </div>
                        )}

                        {/* Maze Grid */}
                        <div 
                            className="maze-grid rounded-lg overflow-hidden shadow-2xl"
                            style={{ 
                                gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)`,
                                width: 'min(90vw, 500px)', // Responsive width
                            }}
                        >
                            {grid.map((row, y) => (
                                row.map((cell, x) => (
                                    <div key={`${x}-${y}`} className={`cell ${cell === 1 ? 'wall' : cell === 2 ? 'start' : cell === 3 ? 'end' : ''}`}>
                                        {/* Render Player if position matches */}
                                        {player.x === x && player.y === y && (
                                            <div className="absolute inset-0 flex items-center justify-center z-10">
                                                <MouseIcon />
                                            </div>
                                        )}
                                        {/* Render Goal */}
                                        {cell === 3 && (
                                            <div className="absolute inset-0 flex items-center justify-center opacity-50">
                                                <CheeseIcon />
                                            </div>
                                        )}
                                    </div>
                                ))
                            ))}
                        </div>
                    </div>

                    {/* Teacher Controls */}
                    <div className="w-full max-w-md flex flex-col gap-4">
                        
                        {/* Feedback Display */}
                        <div className="bg-white p-3 rounded-lg shadow text-center min-h-[60px] flex items-center justify-center">
                            <span className="text-lg font-medium text-slate-700">
                                {transcript || "Waiting for command..."}
                            </span>
                        </div>
                        
                        {/* Big Mic Button */}
                        <button 
                            className={`w-full py-6 rounded-2xl font-bold text-2xl shadow-lg transition-all touch-manipulation ${
                                isListening 
                                    ? 'bg-red-500 text-white active:bg-red-600 shadow-red-200' 
                                    : 'bg-blue-500 text-white active:bg-blue-600 shadow-blue-200'
                            }`}
                            onMouseDown={toggleListen}
                            onTouchStart={toggleListen} // Better latency on iOS
                            disabled={gameState === 'START' || gameState === 'WON'}
                        >
                            {isListening ? "STOP LISTENING" : "TAP TO LISTEN"}
                        </button>
                        
                        <p className="text-center text-slate-400 text-xs mt-2">
                            {errorMsg || "Teacher: Tap button to toggle voice recognition"}
                        </p>
                    </div>

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
