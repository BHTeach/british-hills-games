<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Classroom Maze</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* iOS Safari Specific Tweaks */
        body {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
            background-color: #000;
        }
        
        .maze-grid {
            display: grid;
            gap: 1px; /* Tighter gap for larger grid */
            background-color: #000;
            border: 4px solid #1e293b;
        }
        
        .cell {
            position: relative;
            background-color: #e2e8f0; /* Path */
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .wall {
            background-color: #0f172a; /* Wall */
        }
        
        .start {
            background-color: #60a5fa; /* Start Zone */
        }
        
        .end {
            background-color: #4ade80; /* End Zone */
        }
        
        .character {
            transition: all 0.3s ease-in-out;
        }

        .safe-padding {
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
    </style>
</head>
<body class="h-[100dvh] w-screen overflow-hidden text-white">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Game Constants ---
        const GRID_SIZE = 11; // Increased size
        
        // 0: Empty, 1: Wall, 2: Start, 3: End
        const LEVEL_1 = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 1, 0, 0, 0, 1, 0, 0, 1], // Start at 1,1
            [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1], // End at 9,9
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        // Initial Positions
        const INITIAL_PLAYER = { x: 1, y: 1, dir: 1 };
        const INITIAL_CAT = { x: 9, y: 1 }; // Top right corner

        // Directions: 0: Up, 1: Right, 2: Down, 3: Left
        const DIRECTIONS = [
            { dx: 0, dy: -1, label: 'North' },
            { dx: 1, dy: 0, label: 'East' },
            { dx: 0, dy: 1, label: 'South' },
            { dx: -1, dy: 0, label: 'West' },
        ];

        // --- Audio Helpers ---
        const audioCtxRef = { current: null };

        const initAudio = () => {
            if (!audioCtxRef.current) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtxRef.current = new AudioContext();
            }
            if (audioCtxRef.current.state === 'suspended') {
                audioCtxRef.current.resume();
            }
        };

        const playTone = (freq, type, duration) => {
            if (!audioCtxRef.current) return;
            const osc = audioCtxRef.current.createOscillator();
            const gain = audioCtxRef.current.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtxRef.current.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtxRef.current.destination);
            osc.start();
            osc.stop(audioCtxRef.current.currentTime + duration);
        };

        const playMoveSound = () => playTone(300, 'sine', 0.1);
        const playBumpSound = () => playTone(150, 'sawtooth', 0.2);
        const playWinSound = () => {
            playTone(400, 'sine', 0.1);
            setTimeout(() => playTone(600, 'sine', 0.1), 100);
            setTimeout(() => playTone(800, 'sine', 0.2), 200);
        };
        const playLoseSound = () => {
            playTone(300, 'sawtooth', 0.2);
            setTimeout(() => playTone(200, 'sawtooth', 0.4), 200);
        };
        const playListenSound = () => playTone(800, 'sine', 0.05);

        // --- Logic: BFS for Cat Pathfinding ---
        const getNextCatMove = (catPos, playerPos, grid) => {
            // BFS to find the shortest path to the player
            // Returns the coordinate of the immediate next step
            
            const queue = [{ x: catPos.x, y: catPos.y, path: [] }];
            const visited = new Set();
            visited.add(`${catPos.x},${catPos.y}`);

            // Safety break counter
            let iterations = 0;

            while (queue.length > 0 && iterations < 500) {
                iterations++;
                const current = queue.shift();
                const { x, y, path } = current;

                // Found player? Return first step
                if (x === playerPos.x && y === playerPos.y) {
                    return path.length > 0 ? path[0] : catPos;
                }

                // Check neighbors
                const moves = [
                    {dx: 0, dy: -1}, {dx: 0, dy: 1}, 
                    {dx: -1, dy: 0}, {dx: 1, dy: 0}
                ];

                for (const move of moves) {
                    const nx = x + move.dx;
                    const ny = y + move.dy;
                    
                    if (nx >= 0 && ny >= 0 && nx < GRID_SIZE && ny < GRID_SIZE) {
                        const cell = grid[ny][nx];
                        const posKey = `${nx},${ny}`;
                        
                        // Valid move if not a wall and not visited
                        if (cell !== 1 && !visited.has(posKey)) {
                            visited.add(posKey);
                            queue.push({
                                x: nx,
                                y: ny,
                                path: [...path, {x: nx, y: ny}]
                            });
                        }
                    }
                }
            }
            // If no path found (shouldn't happen in solvable maze), stay still
            return catPos;
        };


        // --- Main Component ---
        function App() {
            // Game State
            const [gameState, setGameState] = useState('START'); // START, PLAYING, WON, LOST
            const [player, setPlayer] = useState(INITIAL_PLAYER);
            const [cat, setCat] = useState(INITIAL_CAT);
            const [grid, setGrid] = useState(LEVEL_1);
            
            // Speech State
            const [isListening, setIsListening] = useState(false);
            const [transcript, setTranscript] = useState("");
            const [errorMsg, setErrorMsg] = useState("");

            // Refs
            const recognitionRef = useRef(null);
            const playerRef = useRef(player);
            const catRef = useRef(cat);
            const gridRef = useRef(grid);
            const gameStateRef = useRef(gameState);
            const shouldListenRef = useRef(false);

            // Sync Refs
            useEffect(() => { playerRef.current = player; }, [player]);
            useEffect(() => { catRef.current = cat; }, [cat]);
            useEffect(() => { gridRef.current = grid; }, [grid]);
            useEffect(() => { gameStateRef.current = gameState; }, [gameState]);

            // --- Game Logic ---
            const resetGame = () => {
                setPlayer(INITIAL_PLAYER);
                setCat(INITIAL_CAT);
                setGameState('PLAYING');
                setTranscript("Ready!");
                initAudio();
            };

            const isValidMove = (x, y) => {
                if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;
                return gridRef.current[y][x] !== 1; // 1 is Wall
            };

            const checkGameStatus = (pPos, cPos) => {
                // Check Win
                if (gridRef.current[pPos.y][pPos.x] === 3) {
                    setGameState('WON');
                    playWinSound();
                    speak("You won!");
                    return true;
                }
                // Check Loss (Cat caught mouse)
                if (pPos.x === cPos.x && pPos.y === cPos.y) {
                    setGameState('LOST');
                    playLoseSound();
                    speak("Oh no! The cat caught you.");
                    return true;
                }
                return false;
            };

            const speak = (text) => {
                if ('speechSynthesis' in window) {
                     const utterance = new SpeechSynthesisUtterance(text);
                     window.speechSynthesis.speak(utterance);
                }
            };

            const processCommandRef = useRef();
            processCommandRef.current = (text) => {
                if (gameStateRef.current !== 'PLAYING') return;

                const p = playerRef.current;
                const c = catRef.current;
                
                let newX = p.x;
                let newY = p.y;
                let newDir = p.dir;
                let commandFound = false;
                let action = "";
                let didMove = false;

                // Cleanup text
                const cleanText = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").trim().toLowerCase();

                // Logic
                if (cleanText === "go forward") {
                    newX += DIRECTIONS[p.dir].dx;
                    newY += DIRECTIONS[p.dir].dy;
                    action = "Forward";
                    commandFound = true;
                    didMove = true;
                } else if (cleanText === "go back") {
                    newX -= DIRECTIONS[p.dir].dx;
                    newY -= DIRECTIONS[p.dir].dy;
                    action = "Back";
                    commandFound = true;
                    didMove = true;
                } else if (cleanText === "turn left") {
                    newDir = (p.dir - 1 + 4) % 4;
                    action = "Turn Left";
                    commandFound = true;
                } else if (cleanText === "turn right") {
                    newDir = (p.dir + 1) % 4;
                    action = "Turn Right";
                    commandFound = true;
                }

                if (commandFound) {
                    setTranscript(`Cmd: ${action}`);
                    
                    if (action.includes("Turn")) {
                        // Just turn, Cat does NOT move on turns (gives students time to think)
                        setPlayer({ ...p, dir: newDir });
                        playMoveSound();
                    } else {
                        // Movement
                        if (isValidMove(newX, newY)) {
                            // 1. Move Player
                            const nextPlayerPos = { ...p, x: newX, y: newY };
                            setPlayer(nextPlayerPos);
                            playMoveSound();

                            // 2. Check collisions immediately
                            if (checkGameStatus(nextPlayerPos, c)) return;

                            // 3. Move Cat (Only if player actually moved)
                            if (didMove) {
                                const nextCatPos = getNextCatMove(c, nextPlayerPos, gridRef.current);
                                setCat(nextCatPos);

                                // 4. Check collisions after cat moves
                                setTimeout(() => {
                                    // Small delay to ensure state update doesn't race, though checking calculated values is safer
                                    checkGameStatus(nextPlayerPos, nextCatPos);
                                }, 50);
                            }

                        } else {
                            playBumpSound();
                            setTranscript("Bonk! Wall.");
                        }
                    }
                } else {
                    const display = cleanText.length > 20 ? cleanText.substring(0, 20) + "..." : cleanText;
                    setTranscript(`Ignored: "${display}"`);
                }
            };

            // --- Speech Initialization ---
            useEffect(() => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (SpeechRecognition) {
                    const recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = false;
                    recognition.lang = 'en-US';

                    recognition.onstart = () => { setIsListening(true); setTranscript("Listening..."); setErrorMsg(""); };
                    recognition.onend = () => {
                        setIsListening(false);
                        if (shouldListenRef.current && gameStateRef.current === 'PLAYING') {
                            try { recognition.start(); } catch (e) {}
                        }
                    };
                    recognition.onerror = (event) => {
                        if (event.error === 'not-allowed') {
                            setErrorMsg("Microphone denied.");
                            shouldListenRef.current = false;
                            setIsListening(false);
                        }
                    };
                    recognition.onresult = (event) => {
                        const latestResult = event.results[event.results.length - 1];
                        if (latestResult.isFinal) processCommandRef.current(latestResult[0].transcript);
                    };
                    recognitionRef.current = recognition;
                } else {
                    setErrorMsg("Browser not supported.");
                }

                return () => {
                    shouldListenRef.current = false;
                    if (recognitionRef.current) recognitionRef.current.abort();
                };
            }, []);

            // --- Manual Controls ---
            const toggleListen = () => {
                if (!recognitionRef.current) return;
                initAudio();
                
                if (isListening) {
                    shouldListenRef.current = false;
                    recognitionRef.current.stop();
                } else {
                    shouldListenRef.current = true;
                    playListenSound();
                    try { recognitionRef.current.start(); } catch (e) {}
                }
            };

            // --- Icons ---
            const getMouseRotation = () => player.dir * 90;
            
            const MouseIcon = () => (
                <svg width="70%" height="70%" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ transform: `rotate(${getMouseRotation()}deg)`, transition: 'transform 0.3s' }}>
                    <path d="M12 2L19 22L12 18L5 22L12 2Z" fill="#3b82f6" />
                </svg>
            );
            
            const CatIcon = () => (
                <svg width="70%" height="70%" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <circle cx="12" cy="12" r="10" fill="#ef4444" opacity="0.8" />
                    <path d="M8 8L16 16M16 8L8 16" stroke="white" strokeWidth="3" />
                    <circle cx="9" cy="9" r="1.5" fill="black"/>
                    <circle cx="15" cy="9" r="1.5" fill="black"/>
                    <path d="M10 16 Q12 18 14 16" stroke="black" fill="transparent"/>
                </svg>
            );

            const CheeseIcon = () => (
                 <svg width="70%" height="70%" viewBox="0 0 24 24" fill="none" stroke="#16a34a" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 2C8 2 4 6 4 10V18C4 20 6 22 10 22H14C18 22 20 20 20 18V10C20 6 16 2 12 2Z" />
                    <circle cx="10" cy="10" r="2" fill="#16a34a"/>
                    <circle cx="14" cy="14" r="2" fill="#16a34a"/>
                </svg>
            );

            return (
                <div className="safe-padding flex flex-col md:flex-row h-full w-full items-center justify-center p-4 gap-6 bg-black">
                    
                    {/* LEFT SIDE: MAZE */}
                    <div className="flex-1 h-full max-h-[95vh] aspect-square flex items-center justify-center relative">
                        
                        {/* Overlays */}
                        {gameState === 'START' && (
                            <div className="absolute inset-0 z-20 bg-black/80 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm border border-slate-700">
                                <h2 className="text-white text-4xl font-bold mb-6">Classroom Maze</h2>
                                <button onClick={resetGame} className="px-10 py-5 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold text-2xl shadow-lg">
                                    Start Game
                                </button>
                            </div>
                        )}

                        {gameState === 'WON' && (
                            <div className="absolute inset-0 z-20 bg-green-900/90 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm border border-green-500">
                                <h2 className="text-white text-5xl font-bold mb-6">Great Job! ðŸŽ‰</h2>
                                <button onClick={resetGame} className="px-10 py-5 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold text-2xl shadow-lg">
                                    Play Again
                                </button>
                            </div>
                        )}

                        {gameState === 'LOST' && (
                            <div className="absolute inset-0 z-20 bg-red-900/90 flex flex-col items-center justify-center rounded-xl backdrop-blur-sm border border-red-500">
                                <h2 className="text-white text-5xl font-bold mb-6">Cat Caught You! ðŸ™€</h2>
                                <button onClick={resetGame} className="px-10 py-5 bg-red-600 hover:bg-red-700 text-white rounded-xl font-bold text-2xl shadow-lg">
                                    Try Again
                                </button>
                            </div>
                        )}

                        <div 
                            className="maze-grid rounded-lg overflow-hidden shadow-2xl w-full h-full"
                            style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)` }}
                        >
                            {grid.map((row, y) => (
                                row.map((cell, x) => (
                                    <div key={`${x}-${y}`} className={`cell ${cell === 1 ? 'wall' : cell === 2 ? 'start' : cell === 3 ? 'end' : ''}`}>
                                        
                                        {/* Player */}
                                        {player.x === x && player.y === y && (
                                            <div className="absolute inset-0 flex items-center justify-center z-10 text-blue-500">
                                                <MouseIcon />
                                            </div>
                                        )}
                                        
                                        {/* Cat */}
                                        {cat.x === x && cat.y === y && (
                                            <div className="absolute inset-0 flex items-center justify-center z-10 text-red-500">
                                                <CatIcon />
                                            </div>
                                        )}

                                        {/* Goal */}
                                        {cell === 3 && (
                                            <div className="absolute inset-0 flex items-center justify-center opacity-70">
                                                <CheeseIcon />
                                            </div>
                                        )}
                                    </div>
                                ))
                            ))}
                        </div>
                    </div>

                    {/* RIGHT SIDE: CONTROLS */}
                    <div className="w-full md:w-1/3 flex flex-col gap-6 justify-center">
                        
                        {/* Status Box */}
                        <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl text-center">
                            <h2 className="text-slate-400 text-sm uppercase tracking-wider mb-2">Command Heard</h2>
                            <div className="text-2xl font-mono font-bold text-yellow-400 min-h-[40px]">
                                {transcript || "..."}
                            </div>
                        </div>
                        
                        {/* Big Start/Stop Button */}
                        <button 
                            className={`w-full py-8 rounded-2xl font-bold text-3xl shadow-lg transition-all border-4 ${
                                isListening 
                                    ? 'bg-red-600 border-red-800 text-white animate-pulse' 
                                    : 'bg-green-600 border-green-800 text-white hover:bg-green-500'
                            }`}
                            onMouseDown={toggleListen}
                            onTouchStart={toggleListen}
                            disabled={gameState === 'WON' || gameState === 'LOST'}
                        >
                            {isListening ? "STOP LISTENING" : "START GAME"}
                        </button>
                        
                        {/* Cheat Sheet */}
                        <div className="bg-slate-900 border border-slate-700 p-4 rounded-xl">
                            <h3 className="text-slate-500 text-xs uppercase mb-2">Valid Commands</h3>
                            <div className="grid grid-cols-2 gap-2 text-sm text-slate-300 font-mono">
                                <div className="bg-slate-800 p-2 rounded">Go forward</div>
                                <div className="bg-slate-800 p-2 rounded">Go back</div>
                                <div className="bg-slate-800 p-2 rounded">Turn left</div>
                                <div className="bg-slate-800 p-2 rounded">Turn right</div>
                            </div>
                        </div>
                    </div>

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
