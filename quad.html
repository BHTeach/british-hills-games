<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>British Hills: Quad Rivals</title>
    <!-- Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Lato:wght@400;900&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #1a1a1a; 
            font-family: 'Lato', sans-serif;
            touch-action: none;
        }
        
        .header-font { font-family: 'Cinzel', serif; }
        
        /* Felt Table Texture */
        #game-container {
            background-color: #0f4c3a; /* Snooker Green */
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0.3) 100%),
                url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
            box-shadow: inset 0 0 100px #000;
        }

        .interactive { pointer-events: auto; }
        
        /* Team Zones */
        .zone-label {
            position: absolute;
            font-weight: 900;
            text-transform: uppercase;
            opacity: 0.3;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .active-turn { opacity: 1 !important; text-shadow: 0 0 20px white; }

        /* UI Panel */
        .glass-panel {
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: all 0.2s;
        }
        .glass-panel:hover {
            background: rgba(40, 40, 40, 0.9);
        }

        /* Aim Arrow */
        #aim-line {
            position: absolute;
            height: 4px;
            /* Gradient to show motion direction (tail is faint, head is solid) */
            background: linear-gradient(90deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,1) 100%);
            transform-origin: left center;
            display: none;
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 0 10px white;
            border-radius: 2px;
        }

        /* The Arrow Head */
        #aim-line::after {
            content: '';
            position: absolute;
            right: -8px; /* Offset to stick out at the end */
            top: -6px;   /* Center relative to line height (4px) -> -6px + 2px center = -4px visual correction */
            width: 0; 
            height: 0; 
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 12px solid white; /* The arrow tip color */
            filter: drop-shadow(0 0 5px white);
        }

        /* Active Cannon Marker */
        #active-marker {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 4px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            display: none;
            animation: pulse-ring 1.5s infinite;
            box-shadow: 0 0 20px currentColor;
        }

        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 1; border-width: 4px; }
            100% { transform: scale(1.4); opacity: 0; border-width: 0px; }
        }
    </style>
</head>
<body>

    <!-- GAME CONTAINER -->
    <div id="game-container" class="absolute inset-0 z-0 border-[20px] border-[#3e2723] rounded-lg"></div>
    
    <!-- DYNAMIC OVERLAYS -->
    <div id="aim-line"></div>
    <!-- The glowing ring for the active cannon -->
    <div id="active-marker"></div>

    <!-- UI LAYER -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-4">
        
        <!-- TOP ROW (Team 1) -->
        <div class="flex justify-center">
            <div id="score-card-0" class="glass-panel interactive px-6 py-2 rounded-b-xl border-t-4 border-red-500 text-center transform hover:scale-105">
                <div class="text-xs text-red-400 font-bold tracking-widest uppercase mb-1 team-name-0">TEAM 1</div>
                <div class="text-3xl font-black text-white score-0">100</div>
            </div>
        </div>

        <!-- MIDDLE ROW (Team 4 Left, Team 2 Right) -->
        <div class="flex justify-between items-center w-full px-4">
            <!-- Left -->
            <div id="score-card-3" class="glass-panel interactive px-4 py-4 rounded-r-xl border-l-4 border-yellow-500 text-center transform hover:scale-105">
                <div class="text-xs text-yellow-400 font-bold tracking-widest uppercase mb-1 team-name-3 -rotate-90">TEAM 4</div>
                <div class="text-3xl font-black text-white score-3">100</div>
            </div>
            
            <!-- Turn Announcer -->
            <div id="turn-announcer" class="pointer-events-none opacity-0 transition-opacity duration-500 text-center">
                <h1 class="header-font text-5xl text-white drop-shadow-lg" id="turn-text">RED TEAM SHOOTS</h1>
                <p class="text-gray-300">Drag to Aim â€¢ Release to Fire</p>
            </div>

            <!-- Right -->
            <div id="score-card-1" class="glass-panel interactive px-4 py-4 rounded-l-xl border-r-4 border-blue-500 text-center transform hover:scale-105">
                <div class="text-xs text-blue-400 font-bold tracking-widest uppercase mb-1 team-name-1 rotate-90">TEAM 2</div>
                <div class="text-3xl font-black text-white score-1">100</div>
            </div>
        </div>

        <!-- BOTTOM ROW (Team 3 + Controls) -->
        <div class="flex flex-col items-center gap-4">
            <!-- Team 3 Score -->
            <div id="score-card-2" class="glass-panel interactive px-6 py-2 rounded-t-xl border-b-4 border-green-500 text-center transform hover:scale-105">
                <div class="text-xs text-green-400 font-bold tracking-widest uppercase mb-1 team-name-2">TEAM 3</div>
                <div class="text-3xl font-black text-white score-2">100</div>
            </div>

            <!-- Controls -->
            <div class="flex gap-4 interactive pb-4">
                <button onclick="toggleSetup()" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded font-bold shadow-lg">SETUP TEAMS</button>
                <button onclick="manualReset()" class="bg-indigo-600 hover:bg-indigo-500 text-white px-6 py-2 rounded font-bold shadow-lg">RESET BLOCKS</button>
            </div>
        </div>
    </div>

    <!-- SETUP MODAL -->
    <div id="setup-modal" class="absolute inset-0 z-50 bg-black bg-opacity-90 flex items-center justify-center">
        <div class="bg-gray-900 border border-gray-700 p-8 rounded-xl w-full max-w-2xl shadow-2xl">
            <h1 class="header-font text-4xl text-white mb-2 text-center">QUAD RIVALS</h1>
            <p class="text-gray-400 text-center mb-8">Enter team names to begin the siege.</p>
            
            <div class="grid grid-cols-2 gap-6 mb-8">
                <div>
                    <label class="text-red-500 font-bold text-sm block mb-1">NORTH TEAM (Red)</label>
                    <input type="text" id="input-name-0" class="w-full bg-gray-800 text-white p-3 rounded border border-gray-600 focus:border-red-500 outline-none" placeholder="The Lions">
                </div>
                <div>
                    <label class="text-blue-500 font-bold text-sm block mb-1">EAST TEAM (Blue)</label>
                    <input type="text" id="input-name-1" class="w-full bg-gray-800 text-white p-3 rounded border border-gray-600 focus:border-blue-500 outline-none" placeholder="The Sharks">
                </div>
                <div>
                    <label class="text-green-500 font-bold text-sm block mb-1">SOUTH TEAM (Green)</label>
                    <input type="text" id="input-name-2" class="w-full bg-gray-800 text-white p-3 rounded border border-gray-600 focus:border-green-500 outline-none" placeholder="The Snakes">
                </div>
                <div>
                    <label class="text-yellow-500 font-bold text-sm block mb-1">WEST TEAM (Yellow)</label>
                    <input type="text" id="input-name-3" class="w-full bg-gray-800 text-white p-3 rounded border border-gray-600 focus:border-yellow-500 outline-none" placeholder="The Eagles">
                </div>
            </div>

            <div class="border-t border-gray-700 pt-6">
                <h3 class="text-white font-bold mb-4">Select First Shooter:</h3>
                <div class="grid grid-cols-4 gap-2 mb-6">
                    <button onclick="startGame(0)" class="bg-red-900 hover:bg-red-700 text-white py-3 rounded font-bold transition">NORTH</button>
                    <button onclick="startGame(1)" class="bg-blue-900 hover:bg-blue-700 text-white py-3 rounded font-bold transition">EAST</button>
                    <button onclick="startGame(2)" class="bg-green-900 hover:bg-green-700 text-white py-3 rounded font-bold transition">SOUTH</button>
                    <button onclick="startGame(3)" class="bg-yellow-900 hover:bg-yellow-700 text-white py-3 rounded font-bold transition">WEST</button>
                </div>
            </div>
        </div>
    </div>

    <!-- TEAM SELECTOR OVERLAY (Between Turns) -->
    <div id="selector-overlay" class="absolute inset-0 z-40 bg-black bg-opacity-40 hidden flex items-center justify-center pointer-events-none">
        <!-- Just visual, clicking a score card activates that team -->
    </div>

    <script>
        // --- GAME CONFIG ---
        const TEAMS = [
            { id: 0, color: '#ef4444', name: 'NORTH', base: 'top' },    // Red
            { id: 1, color: '#3b82f6', name: 'EAST', base: 'right' },   // Blue
            { id: 2, color: '#22c55e', name: 'SOUTH', base: 'bottom' }, // Green
            { id: 3, color: '#eab308', name: 'WEST', base: 'left' }     // Yellow
        ];

        let state = {
            scores: [100, 100, 100, 100],
            activeTeam: null,
            isAiming: false,
            hasFired: false
        };

        let resetTimer = null; 

        // --- MATTER.JS VARIABLES ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Body = Matter.Body,
              Vector = Matter.Vector;

        let engine, render, runner;
        let width, height;
        let blocks = [];
        let obstacles = [];
        let cannons = [];

        // --- INITIALIZATION ---
        function init() {
            // FIX: Cleanup old engine if exists
            if (render) {
                Render.stop(render);
                render.canvas.remove();
                render.canvas = null;
                render.context = null;
                render.textures = {};
            }
            if (runner) {
                Runner.stop(runner);
            }
            if (engine) {
                Matter.World.clear(engine.world);
                Engine.clear(engine);
            }

            // Recalculate dimensions
            width = window.innerWidth - 40; 
            height = window.innerHeight - 40;

            engine = Engine.create();
            engine.world.gravity.y = 0; 
            engine.world.gravity.x = 0;

            const container = document.getElementById('game-container');
            container.innerHTML = ''; // Clear any previous canvases

            render = Render.create({
                element: container,
                engine: engine,
                options: {
                    width: width,
                    height: height,
                    wireframes: false,
                    background: 'transparent',
                    pixelRatio: window.devicePixelRatio
                }
            });

            const wallOpt = { isStatic: true, render: { fillStyle: '#3e2723' }, restitution: 1.0 };
            const walls = [
                Bodies.rectangle(width/2, -25, width, 50, wallOpt), 
                Bodies.rectangle(width/2, height+25, width, 50, wallOpt), 
                Bodies.rectangle(-25, height/2, 50, height, wallOpt), 
                Bodies.rectangle(width+25, height/2, 50, height, wallOpt) 
            ];
            Composite.add(engine.world, walls);

            Events.on(engine, 'collisionStart', handleCollisions);

            // Re-bind input events (safely handles duplicate binds by clearing container first)
            container.removeEventListener('pointerdown', handleInputStart);
            container.removeEventListener('pointermove', handleInputMove);
            container.removeEventListener('pointerup', handleInputEnd);
            
            container.addEventListener('pointerdown', handleInputStart);
            container.addEventListener('pointermove', handleInputMove);
            container.addEventListener('pointerup', handleInputEnd);

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
            
            buildBoard();
        }

        // --- BOARD GENERATION ---
        function buildBoard() {
            if(resetTimer) {
                clearTimeout(resetTimer);
                resetTimer = null;
            }

            Composite.remove(engine.world, blocks);
            Composite.remove(engine.world, obstacles);
            Composite.remove(engine.world, cannons);
            
            const balls = Composite.allBodies(engine.world).filter(b => b.label === 'BALL');
            Composite.remove(engine.world, balls);

            blocks = [];
            obstacles = [];
            cannons = [];

            const obsOpt = { isStatic: true, render: { fillStyle: '#1f2937' }, restitution: 1.0 };
            obstacles.push(Bodies.polygon(width/2, height/2, 4, 60, { ...obsOpt, angle: Math.PI/4 }));
            
            const inset = 200;
            obstacles.push(Bodies.circle(inset, inset, 30, obsOpt));
            obstacles.push(Bodies.circle(width-inset, inset, 30, obsOpt));
            obstacles.push(Bodies.circle(width-inset, height-inset, 30, obsOpt));
            obstacles.push(Bodies.circle(inset, height-inset, 30, obsOpt));

            const blockOpt = (teamId) => ({
                label: `BLOCK_${teamId}`,
                isStatic: true,
                render: { fillStyle: TEAMS[teamId].color, strokeStyle: '#fff', lineWidth: 2 },
                restitution: 0.5
            });

            const placeRow = (teamId, startX, startY, count, dirX, dirY) => {
                for(let i=0; i<count; i++) {
                    const b = Bodies.rectangle(
                        startX + (dirX * i * 40), 
                        startY + (dirY * i * 40), 
                        30, 30, 
                        blockOpt(teamId)
                    );
                    blocks.push(b);
                }
            };

            placeRow(0, width/2 - 60, 80, 4, 1, 0); 
            placeRow(1, width - 80, height/2 - 60, 4, 0, 1); 
            placeRow(2, width/2 - 60, height - 80, 4, 1, 0);
            placeRow(3, 80, height/2 - 60, 4, 0, 1);

            const cannonOpt = (color) => ({ isStatic: true, isSensor: true, render: { fillStyle: color, opacity: 0.5 } });
            
            const pos0 = getCannonPos(0);
            const pos1 = getCannonPos(1);
            const pos2 = getCannonPos(2);
            const pos3 = getCannonPos(3);

            cannons.push(Bodies.circle(pos0.x, pos0.y, 20, cannonOpt(TEAMS[0].color)));
            cannons.push(Bodies.circle(pos1.x, pos1.y, 20, cannonOpt(TEAMS[1].color)));
            cannons.push(Bodies.circle(pos2.x, pos2.y, 20, cannonOpt(TEAMS[2].color)));
            cannons.push(Bodies.circle(pos3.x, pos3.y, 20, cannonOpt(TEAMS[3].color)));

            Composite.add(engine.world, [...obstacles, ...blocks, ...cannons]);
            
            state.hasFired = false;

            if(state.activeTeam !== null) {
                updateActiveMarker(state.activeTeam);
            }
        }

        function manualReset() {
            if(resetTimer) clearTimeout(resetTimer);
            buildBoard();
            if(state.activeTeam !== null) {
                document.getElementById('turn-announcer').style.opacity = 1;
                document.getElementById('active-marker').style.display = 'block';
            }
        }

        // --- GAMEPLAY LOGIC ---

        function updateActiveMarker(id) {
            const origin = getCannonPos(id);
            const marker = document.getElementById('active-marker');
            
            // FIX: Add +20px offset to align visual marker with Canvas inside bordered container
            marker.style.left = (origin.x - 30 + 20) + 'px'; 
            marker.style.top = (origin.y - 30 + 20) + 'px';
            
            marker.style.display = 'block';
            marker.style.borderColor = TEAMS[id].color;
            marker.style.color = TEAMS[id].color; 
        }

        function setActiveTeam(id) {
            if(resetTimer) {
                clearTimeout(resetTimer);
                resetTimer = null;
            }
            
            state.activeTeam = id;
            state.hasFired = false;
            
            updateActiveMarker(id);

            const announcer = document.getElementById('turn-announcer');
            const text = document.getElementById('turn-text');
            text.innerText = `${TEAMS[id].name} SHOOTS`;
            text.style.color = TEAMS[id].color;
            announcer.style.opacity = 1;

            TEAMS.forEach(t => {
                const card = document.getElementById(`score-card-${t.id}`);
                if (t.id === id) {
                    card.classList.add('scale-110', 'border-white');
                    card.style.opacity = '1';
                } else {
                    card.classList.remove('scale-110', 'border-white');
                    card.style.opacity = '0.6';
                }
            });
        }

        function startGame(firstShooterId) {
            TEAMS[0].name = document.getElementById('input-name-0').value || "NORTH";
            TEAMS[1].name = document.getElementById('input-name-1').value || "EAST";
            TEAMS[2].name = document.getElementById('input-name-2').value || "SOUTH";
            TEAMS[3].name = document.getElementById('input-name-3').value || "WEST";
            
            TEAMS.forEach(t => {
                document.querySelector(`.team-name-${t.id}`).innerText = t.name;
            });

            document.getElementById('setup-modal').style.display = 'none';
            init(); 
            setTimeout(() => setActiveTeam(firstShooterId), 100);
        }

        function toggleSetup() {
            const modal = document.getElementById('setup-modal');
            modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
        }

        // --- INPUT & SHOOTING ---
        let dragStart = null;

        function handleInputStart(e) {
            if (e.target.tagName === 'BUTTON') return;
            if (state.activeTeam === null || state.hasFired) return;
            dragStart = { x: e.clientX, y: e.clientY };
        }

        function handleInputMove(e) {
            if (!dragStart) return;
            
            const mousePos = { x: e.clientX, y: e.clientY };
            const dx = dragStart.x - mousePos.x;
            const dy = dragStart.y - mousePos.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            
            const line = document.getElementById('aim-line');
            if (len > 10) {
                let origin = getCannonPos(state.activeTeam);
                
                const angle = Math.atan2(dy, dx);
                const visualLen = Math.min(len, 300);

                line.style.display = 'block';
                line.style.width = visualLen + 'px';
                // FIX: Add +20px offset to align Aim Line with Canvas inside bordered container
                line.style.left = (origin.x + 20) + 'px';
                line.style.top = (origin.y + 20) + 'px';
                line.style.transform = `rotate(${angle}rad)`;
            }
        }

        function handleInputEnd(e) {
            if (!dragStart) return;
            
            const mousePos = { x: e.clientX, y: e.clientY };
            const dx = dragStart.x - mousePos.x;
            const dy = dragStart.y - mousePos.y;
            const len = Math.sqrt(dx*dx + dy*dy);

            if (len > 20) {
                fireProjectile(dx, dy);
            }

            dragStart = null;
            document.getElementById('aim-line').style.display = 'none';
        }

        function getCannonPos(teamId) {
            if (!width || !height) return {x:0, y:0};
            if(teamId === 0) return { x: width/2, y: 140 }; 
            if(teamId === 1) return { x: width-140, y: height/2 }; 
            if(teamId === 2) return { x: width/2, y: height-140 }; 
            if(teamId === 3) return { x: 140, y: height/2 }; 
            return {x:0, y:0};
        }

        function fireProjectile(dx, dy) {
            if (resetTimer) {
                clearTimeout(resetTimer);
                resetTimer = null;
            }

            state.hasFired = true;
            document.getElementById('turn-announcer').style.opacity = 0;
            document.getElementById('active-marker').style.display = 'none'; 

            const origin = getCannonPos(state.activeTeam);
            const force = 0.035; 

            const ball = Bodies.circle(origin.x, origin.y, 10, {
                label: 'BALL',
                density: 0.05,
                restitution: 0.9, 
                friction: 0,
                frictionAir: 0.005, 
                render: { fillStyle: '#fff' }
            });

            Composite.add(engine.world, ball);
            Body.applyForce(ball, ball.position, { x: dx * force, y: dy * force });
            
            resetTimer = setTimeout(() => {
                manualReset(); 
                resetTimer = null;
            }, 8000);
        }

        // --- COLLISION & SCORING ---
        function handleCollisions(event) {
            event.pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                let block = null;
                if (bodyA.label.startsWith('BLOCK_') && bodyB.label === 'BALL') block = bodyA;
                else if (bodyB.label.startsWith('BLOCK_') && bodyA.label === 'BALL') block = bodyB;

                if (block) {
                    const victimId = parseInt(block.label.split('_')[1]);
                    
                    if (victimId !== state.activeTeam) {
                        // Hit enemy: Steal points
                        stealPoints(state.activeTeam, victimId, 10);
                    } else {
                        // Hit self: Penalty
                        penalizeSelf(state.activeTeam, 10);
                    }

                    Composite.remove(engine.world, block);
                    createParticles(block.position.x, block.position.y, TEAMS[victimId].color);
                }
            });
        }

        function stealPoints(thiefId, victimId, amount) {
            state.scores[thiefId] += amount;
            state.scores[victimId] = Math.max(0, state.scores[victimId] - amount);
            updateScoreUI();
        }

        function penalizeSelf(teamId, amount) {
            state.scores[teamId] = Math.max(0, state.scores[teamId] - amount);
            updateScoreUI();
        }

        function updateScoreUI() {
            TEAMS.forEach(t => {
                document.querySelector(`.score-${t.id}`).innerText = state.scores[t.id];
            });
        }

        function createParticles(x, y, color) {
            const pContainer = document.getElementById('ui-layer');
            const el = document.createElement('div');
            el.className = 'absolute w-4 h-4 rounded-full pointer-events-none';
            el.style.backgroundColor = color;
            // FIX: Add +20px offset to align Particles with Canvas
            el.style.left = (x + 20) + 'px';
            el.style.top = (y + 20) + 'px';
            el.style.transition = 'all 0.5s ease-out';
            pContainer.appendChild(el);

            requestAnimationFrame(() => {
                el.style.transform = `translate(${(Math.random()-0.5)*100}px, ${(Math.random()-0.5)*100}px) scale(0)`;
                el.style.opacity = 0;
            });

            setTimeout(() => el.remove(), 500);
        }

        // --- EVENT LISTENERS ---
        // Setup persistent listeners for score cards only once
        document.addEventListener('DOMContentLoaded', () => {
            TEAMS.forEach(t => {
                document.getElementById(`score-card-${t.id}`).addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    setActiveTeam(t.id);
                });
            });
        });

        window.addEventListener('resize', () => {
            width = window.innerWidth - 40;
            height = window.innerHeight - 40;
            
            if (render && render.canvas) {
                render.canvas.width = width;
                render.canvas.height = height;
            }
        });

    </script>
</body>
</html>