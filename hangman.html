<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classroom Hangman</title>
    
    <!-- Tailwind CSS (for styling) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (Core libraries) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (To translate JSX in the browser) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts for better presentation -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        .animate-bounce-short { animation: bounce-short 0.5s infinite alternate; }
        @keyframes bounce-short { from { transform: translateY(0); } to { transform: translateY(-5px); } }
    </style>
</head>
<body class="bg-slate-100 text-gray-900 selection:bg-blue-200">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;

        // --- ICONS (Replaced lucide-react imports with inline SVGs for browser compatibility) ---
        
        const IconBase = ({ children, className = "w-6 h-6" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Trophy = (props) => <IconBase {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></IconBase>;
        const Settings = (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const Play = (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const XCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></IconBase>;
        const Users = (props) => <IconBase {...props}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></IconBase>;
        const Type = (props) => <IconBase {...props}><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></IconBase>;
        const ArrowRight = (props) => <IconBase {...props}><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></IconBase>;

        // --- COMPONENTS ---

        // 1. Simple Button Component
        const Button = ({ onClick, children, variant = 'primary', className = '', disabled = false }) => {
            const baseStyle = "px-6 py-3 rounded-xl font-bold text-xl transition-all active:scale-95 flex items-center justify-center gap-2 shadow-md";
            const variants = {
                primary: "bg-blue-600 hover:bg-blue-700 text-white disabled:bg-gray-400",
                secondary: "bg-gray-200 hover:bg-gray-300 text-gray-800 disabled:bg-gray-100 disabled:text-gray-400",
                success: "bg-green-600 hover:bg-green-700 text-white",
                danger: "bg-red-600 hover:bg-red-700 text-white",
                outline: "border-4 border-gray-300 text-gray-700 hover:border-gray-400"
            };

            return (
                <button 
                onClick={onClick} 
                disabled={disabled}
                className={`${baseStyle} ${variants[variant]} ${className}`}
                >
                {children}
                </button>
            );
        };

        // 2. Hangman SVG Visual
        const HangmanFigure = ({ wrongGuesses }) => {
            const strokeColor = "#374151"; // gray-700
            const strokeWidth = 4;

            return (
                <div className="relative w-48 h-64 mx-auto mb-4">
                <svg viewBox="0 0 200 250" className="w-full h-full overflow-visible">
                    <line x1="20" y1="240" x2="180" y2="240" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />
                    <line x1="60" y1="240" x2="60" y2="20" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />
                    <line x1="60" y1="20" x2="140" y2="20" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />
                    <line x1="140" y1="20" x2="140" y2="50" stroke={strokeColor} strokeWidth={strokeWidth} />

                    {wrongGuesses >= 1 && <circle cx="140" cy="70" r="20" stroke={strokeColor} strokeWidth={strokeWidth} fill="transparent" />}
                    {wrongGuesses >= 2 && <line x1="140" y1="90" x2="140" y2="170" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />}
                    {wrongGuesses >= 3 && <line x1="140" y1="110" x2="110" y2="140" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />}
                    {wrongGuesses >= 4 && <line x1="140" y1="110" x2="170" y2="140" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />}
                    {wrongGuesses >= 5 && <line x1="140" y1="170" x2="110" y2="210" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />}
                    {wrongGuesses >= 6 && <line x1="140" y1="170" x2="170" y2="210" stroke={strokeColor} strokeWidth={strokeWidth} strokeLinecap="round" />}
                </svg>
                </div>
            );
        };

        // --- MAIN APP ---

        function App() {
            // App States: 'setup', 'playing', 'round-end', 'game-over'
            const [gameState, setGameState] = useState('setup');
            
            // Configuration State
            const [config, setConfig] = useState({
                numRounds: 1,
                teamCount: 2,
                words: ['']
            });

            // Gameplay State
            const [currentRound, setCurrentRound] = useState(0);
            const [scores, setScores] = useState([0, 0, 0, 0]); 
            const [activeTeam, setActiveTeam] = useState(0);
            const [guessedLetters, setGuessedLetters] = useState(new Set());
            const [wrongGuesses, setWrongGuesses] = useState(0);

            // Constants
            const MAX_LIVES = 6;
            const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');

            // --- Helpers ---
            const currentWord = useMemo(() => {
                return config.words[currentRound] ? config.words[currentRound].toUpperCase() : "";
            }, [config.words, currentRound]);

            const puzzleState = useMemo(() => {
                const revealed = currentWord.split('').map(char => {
                const isLetter = /[A-Z]/.test(char);
                if (!isLetter) return char; 
                return guessedLetters.has(char) ? char : '_';
                });
                const isWin = !revealed.includes('_');
                return { display: revealed, isWin };
            }, [currentWord, guessedLetters]);

            // --- Handlers ---
            const handleConfigChange = (field, value) => {
                setConfig(prev => ({ ...prev, [field]: value }));
            };

            const handleWordInput = (index, value) => {
                const newWords = [...config.words];
                newWords[index] = value;
                setConfig(prev => ({ ...prev, words: newWords }));
            };

            const adjustRounds = (count) => {
                const newWords = [...config.words];
                if (count > newWords.length) {
                for (let i = newWords.length; i < count; i++) newWords.push('');
                } else {
                newWords.splice(count);
                }
                setConfig(prev => ({ ...prev, numRounds: count, words: newWords }));
            };

            const startGame = () => {
                if (config.words.some(w => w.trim() === '')) return; 
                setScores(new Array(config.teamCount).fill(0));
                setGameState('playing');
                startRound(0);
            };

            const startRound = (roundIndex) => {
                setCurrentRound(roundIndex);
                setGuessedLetters(new Set());
                setWrongGuesses(0);
                setGameState('playing');
            };

            const handleGuess = (letter) => {
                if (gameState !== 'playing' || guessedLetters.has(letter)) return;

                const newGuessed = new Set(guessedLetters);
                newGuessed.add(letter);
                setGuessedLetters(newGuessed);

                if (currentWord.includes(letter)) {
                const newScores = [...scores];
                newScores[activeTeam] += 1;
                setScores(newScores);
                
                const allLettersRevealed = currentWord.split('').every(char => {
                    return !/[A-Z]/.test(char) || newGuessed.has(char);
                });

                if (allLettersRevealed) {
                    const bonusScores = [...newScores];
                    bonusScores[activeTeam] += 5;
                    setScores(bonusScores);
                    setGameState('round-end');
                }

                } else {
                const newWrong = wrongGuesses + 1;
                setWrongGuesses(newWrong);
                if (newWrong >= MAX_LIVES) {
                    setGameState('round-end');
                }
                }
            };

            const nextRound = () => {
                if (currentRound + 1 >= config.numRounds) {
                setGameState('game-over');
                } else {
                startRound(currentRound + 1);
                }
            };

            const resetGame = () => {
                setGameState('setup');
                setConfig({ numRounds: 1, teamCount: 2, words: [''] });
            };

            // --- Screens ---

            const SetupScreen = () => (
                <div className="max-w-2xl mx-auto bg-white p-8 rounded-2xl shadow-xl border-4 border-blue-100 mt-10">
                <div className="flex items-center gap-3 mb-6 border-b pb-4">
                    <Settings className="w-8 h-8 text-blue-600" />
                    <h1 className="text-3xl font-bold text-gray-800">Teacher Setup</h1>
                </div>

                <div className="space-y-6">
                    <div>
                    <label className="block text-gray-700 font-bold mb-2 text-lg">Number of Teams</label>
                    <div className="flex gap-4">
                        {[1, 2, 3, 4].map(num => (
                        <button
                            key={num}
                            onClick={() => handleConfigChange('teamCount', num)}
                            className={`flex-1 py-3 rounded-lg font-bold text-xl border-2 transition-colors ${
                            config.teamCount === num 
                                ? 'bg-blue-100 border-blue-500 text-blue-800' 
                                : 'bg-white border-gray-200 text-gray-500 hover:bg-gray-50'
                            }`}
                        >
                            {num}
                        </button>
                        ))}
                    </div>
                    </div>

                    <div>
                    <label className="block text-gray-700 font-bold mb-2 text-lg">Number of Rounds</label>
                    <select 
                        className="w-full p-3 border-2 border-gray-300 rounded-lg text-xl"
                        value={config.numRounds}
                        onChange={(e) => adjustRounds(Number(e.target.value))}
                    >
                        {[1, 2, 3, 4, 5].map(n => <option key={n} value={n}>{n} Round{n > 1 ? 's' : ''}</option>)}
                    </select>
                    </div>

                    <div className="bg-gray-50 p-4 rounded-xl border border-gray-200">
                    <label className="block text-gray-700 font-bold mb-4 text-lg flex items-center gap-2">
                        <Type className="w-5 h-5" /> Secret Words / Phrases
                    </label>
                    <div className="space-y-3">
                        {config.words.map((word, idx) => (
                        <div key={idx} className="flex items-center gap-3">
                            <span className="font-bold text-gray-400 w-8">#{idx + 1}</span>
                            <input
                            type="text"
                            placeholder="Enter secret word..."
                            className="flex-1 p-3 border-2 border-gray-300 rounded-lg text-lg uppercase tracking-wider font-mono focus:border-blue-500 outline-none"
                            value={word}
                            onChange={(e) => handleWordInput(idx, e.target.value)}
                            />
                        </div>
                        ))}
                    </div>
                    {config.words.some(w => w.trim() === '') && (
                        <p className="text-red-500 text-sm mt-2 font-medium">Please fill in all words to start.</p>
                    )}
                    </div>

                    <Button 
                    onClick={startGame} 
                    className="w-full py-4 text-2xl mt-4" 
                    disabled={config.words.some(w => w.trim() === '')}
                    >
                    <Play className="w-6 h-6" /> Start Game
                    </Button>
                </div>
                </div>
            );

            const PlayingScreen = () => {
                const isRoundOver = gameState === 'round-end';
                const roundWon = isRoundOver && wrongGuesses < MAX_LIVES;

                return (
                <div className="flex flex-col h-full max-w-7xl mx-auto p-4">
                    <div className="bg-white rounded-2xl shadow-lg p-4 mb-6 flex flex-wrap gap-4 justify-between items-stretch border-2 border-gray-100">
                    <div className="flex flex-col justify-center px-6 bg-blue-50 rounded-xl border border-blue-100 min-w-[120px]">
                        <span className="text-sm text-blue-600 font-bold uppercase tracking-wider">Round</span>
                        <span className="text-3xl font-black text-blue-900">{currentRound + 1} / {config.numRounds}</span>
                    </div>

                    <div className="flex flex-wrap gap-2 md:gap-4 justify-end flex-1">
                        {scores.map((score, idx) => (
                        <button 
                            key={idx} 
                            onClick={() => setActiveTeam(idx)}
                            className={`flex flex-col items-center justify-center w-24 md:w-28 py-2 rounded-xl border-2 transition-all ${
                            activeTeam === idx 
                                ? 'bg-yellow-50 border-yellow-400 scale-105 shadow-md ring-2 ring-yellow-200 ring-offset-2' 
                                : 'bg-white border-gray-200 opacity-70 hover:opacity-100'
                            }`}
                        >
                            <span className={`text-xs font-bold uppercase mb-1 ${activeTeam === idx ? 'text-yellow-700' : 'text-gray-400'}`}>
                            Team {idx + 1}
                            </span>
                            <span className="text-4xl font-black text-gray-800">{score}</span>
                        </button>
                        ))}
                    </div>
                    </div>

                    <div className="flex-1 grid grid-cols-1 lg:grid-cols-12 gap-6">
                    <div className="lg:col-span-4 flex flex-col gap-6 order-2 lg:order-1">
                        <div className="bg-white p-4 rounded-2xl shadow-md border-2 border-gray-100 flex-1 flex flex-col items-center justify-center min-h-[300px]">
                        <HangmanFigure wrongGuesses={wrongGuesses} />
                        <div className="font-bold text-red-500 text-xl mt-4">
                            Lives Remaining: <span className="text-2xl">{MAX_LIVES - wrongGuesses}</span>
                        </div>
                        </div>

                        <div className="bg-blue-50 p-4 rounded-xl border border-blue-100 text-blue-800 text-sm font-medium text-center">
                        <Users className="w-4 h-4 inline mr-1" />
                        Tip: Tap scorecards above to change active team.
                        </div>
                    </div>

                    <div className="lg:col-span-8 flex flex-col gap-6 order-1 lg:order-2">
                        <div className="bg-slate-800 rounded-2xl p-6 md:p-8 shadow-inner flex flex-wrap gap-3 justify-center items-center min-h-[160px]">
                        {puzzleState.display.map((char, i) => (
                            <span 
                            key={i}
                            className={`w-10 md:w-12 h-14 md:h-16 flex items-end justify-center text-4xl md:text-5xl font-mono font-bold select-none ${
                                char === '_' 
                                ? 'text-slate-600 border-b-4 border-slate-500' 
                                : 'text-white border-b-4 border-transparent animate-bounce-short'
                            }`}
                            >
                            {char}
                            </span>
                        ))}
                        </div>

                        <div className="bg-white rounded-2xl shadow-md border-2 border-gray-100 p-4 md:p-6 flex-1">
                        <div className="grid grid-cols-7 gap-2 md:gap-3 h-full content-center">
                            {ALPHABET.map((letter) => {
                            const isGuessed = guessedLetters.has(letter);
                            const inWord = currentWord.includes(letter);
                            
                            let btnClass = "bg-gray-100 text-gray-700 hover:bg-gray-200 border-gray-300"; 
                            if (isGuessed) {
                                if (inWord) btnClass = "bg-green-100 text-green-700 border-green-300 opacity-60";
                                else btnClass = "bg-gray-200 text-gray-400 border-gray-200 opacity-40";
                            }

                            return (
                                <button
                                key={letter}
                                disabled={isGuessed || gameState !== 'playing'}
                                onClick={() => handleGuess(letter)}
                                className={`
                                    h-12 md:h-14 rounded-lg font-bold text-xl md:text-2xl border-b-4 active:border-b-0 active:translate-y-1 transition-all
                                    ${btnClass}
                                `}
                                >
                                {letter}
                                </button>
                            );
                            })}
                        </div>
                        </div>

                    </div>
                    </div>

                    {isRoundOver && (
                    <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-lg w-full text-center border-4 border-white animate-in zoom-in duration-300">
                        {roundWon ? (
                            <div className="text-green-600 mb-4 flex justify-center"><Trophy className="w-24 h-24" /></div>
                        ) : (
                            <div className="text-red-500 mb-4 flex justify-center"><XCircle className="w-24 h-24" /></div>
                        )}
                        
                        <h2 className="text-4xl font-black text-gray-800 mb-2">
                            {roundWon ? `Team ${activeTeam + 1} Wins!` : "Round Over"}
                        </h2>
                        
                        <p className="text-gray-500 text-xl font-medium mb-6">
                            {roundWon ? "+5 Bonus Points Awarded" : "The word was not guessed."}
                        </p>

                        <div className="bg-gray-100 rounded-xl p-4 mb-8">
                            <span className="block text-sm text-gray-500 uppercase font-bold tracking-wider mb-1">The Word Was</span>
                            <span className="text-3xl font-mono font-black text-gray-800 tracking-widest break-words">{currentWord}</span>
                        </div>

                        <Button onClick={nextRound} variant="primary" className="w-full py-4 text-xl">
                            {currentRound + 1 >= config.numRounds ? "Finish Game" : "Next Round"} <ArrowRight className="w-6 h-6" />
                        </Button>
                        </div>
                    </div>
                    )}
                </div>
                );
            };

            const GameOverScreen = () => {
                const maxScore = Math.max(...scores);
                const winners = scores
                .map((score, index) => score === maxScore ? index + 1 : null)
                .filter(x => x !== null);

                return (
                <div className="max-w-3xl mx-auto bg-white p-12 rounded-3xl shadow-2xl border-4 border-yellow-100 text-center mt-10">
                    <div className="flex justify-center mb-6">
                    <Trophy className="w-32 h-32 text-yellow-500 drop-shadow-lg" />
                    </div>
                    
                    <h1 className="text-6xl font-black text-gray-800 mb-4">Game Over!</h1>
                    
                    <div className="bg-yellow-50 p-6 rounded-2xl border-2 border-yellow-200 mb-8 inline-block">
                    <p className="text-yellow-800 font-bold text-xl uppercase tracking-wider mb-2">Winning Team</p>
                    <p className="text-5xl font-black text-yellow-600">
                        {winners.length > 1 ? `Tie: Teams ${winners.join(' & ')}` : `Team ${winners[0]}`}
                    </p>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-10">
                    {scores.map((s, i) => (
                        <div key={i} className="bg-gray-50 p-4 rounded-xl border border-gray-200">
                        <span className="block text-gray-400 font-bold text-sm uppercase">Team {i + 1}</span>
                        <span className="block text-3xl font-black text-gray-700">{s} pts</span>
                        </div>
                    ))}
                    </div>

                    <Button onClick={resetGame} variant="outline" className="mx-auto">
                    <RotateCcw className="w-5 h-5" /> Start New Game
                    </Button>
                </div>
                );
            };

            return (
                <div className="min-h-screen">
                {gameState === 'setup' && <SetupScreen />}
                {(gameState === 'playing' || gameState === 'round-end') && <PlayingScreen />}
                {gameState === 'game-over' && <GameOverScreen />}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
